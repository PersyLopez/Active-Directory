{
  "version": 3,
  "sources": ["../../src/lib/executeQuery.ts"],
  "sourcesContent": ["import { IdOf, UnknownRecord } from './BaseRecord'\nimport { intersectSets } from './setUtils'\nimport { StoreQueries } from './StoreQueries'\n\n/**\n * Defines matching criteria for query values. Supports equality, inequality, and greater-than comparisons.\n *\n * @example\n * ```ts\n * // Exact match\n * const exactMatch: QueryValueMatcher<string> = { eq: 'Science Fiction' }\n *\n * // Not equal to\n * const notMatch: QueryValueMatcher<string> = { neq: 'Romance' }\n *\n * // Greater than (numeric values only)\n * const greaterThan: QueryValueMatcher<number> = { gt: 2020 }\n * ```\n *\n * @public\n */\nexport type QueryValueMatcher<T> = { eq: T } | { neq: T } | { gt: number }\n\n/**\n * Query expression for filtering records by their property values. Maps record property names\n * to matching criteria.\n *\n * @example\n * ```ts\n * // Query for books published after 2020 that are in stock\n * const bookQuery: QueryExpression<Book> = {\n *   publishedYear: { gt: 2020 },\n *   inStock: { eq: true }\n * }\n *\n * // Query for books not by a specific author\n * const notByAuthor: QueryExpression<Book> = {\n *   authorId: { neq: 'author:tolkien' }\n * }\n * ```\n *\n * @public\n */\nexport type QueryExpression<R extends object> = {\n\t[k in keyof R & string]?: QueryValueMatcher<R[k]>\n\t// todo: handle nesting\n\t// | (R[k] extends object ? { match: QueryExpression<R[k]> } : never)\n}\n\n/**\n * Tests whether an object matches the given query expression by checking each property\n * against its corresponding matcher criteria.\n *\n * @param query - The query expression containing matching criteria for object properties\n * @param object - The object to test against the query\n * @returns True if the object matches all criteria in the query, false otherwise\n *\n * @example\n * ```ts\n * const book = { title: '1984', publishedYear: 1949, inStock: true }\n * const query = { publishedYear: { gt: 1945 }, inStock: { eq: true } }\n *\n * const matches = objectMatchesQuery(query, book) // true\n * ```\n *\n * @public\n */\nexport function objectMatchesQuery<T extends object>(query: QueryExpression<T>, object: T) {\n\tfor (const [key, _matcher] of Object.entries(query)) {\n\t\tconst matcher = _matcher as QueryValueMatcher<T>\n\t\tconst value = object[key as keyof T]\n\t\t// if you add matching logic here, make sure you also update executeQuery,\n\t\t// where initial data is pulled out of the indexes, since that requires different\n\t\t// matching logic\n\t\tif ('eq' in matcher && value !== matcher.eq) return false\n\t\tif ('neq' in matcher && value === matcher.neq) return false\n\t\tif ('gt' in matcher && (typeof value !== 'number' || value <= matcher.gt)) return false\n\t}\n\treturn true\n}\n\n/**\n * Executes a query against the store using reactive indexes to efficiently find matching record IDs.\n * Uses the store's internal indexes for optimal performance, especially for equality matches.\n *\n * @param store - The store queries interface providing access to reactive indexes\n * @param typeName - The type name of records to query (e.g., 'book', 'author')\n * @param query - Query expression defining the matching criteria\n * @returns A Set containing the IDs of all records that match the query criteria\n *\n * @example\n * ```ts\n * // Find IDs of all books published after 2020 that are in stock\n * const bookIds = executeQuery(store, 'book', {\n *   publishedYear: { gt: 2020 },\n *   inStock: { eq: true }\n * })\n *\n * // Find IDs of books not by a specific author\n * const otherBookIds = executeQuery(store, 'book', {\n *   authorId: { neq: 'author:tolkien' }\n * })\n * ```\n *\n * @public\n */\nexport function executeQuery<R extends UnknownRecord, TypeName extends R['typeName']>(\n\tstore: StoreQueries<R>,\n\ttypeName: TypeName,\n\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n): Set<IdOf<Extract<R, { typeName: TypeName }>>> {\n\tconst matchIds = Object.fromEntries(Object.keys(query).map((key) => [key, new Set()]))\n\n\tfor (const [k, matcher] of Object.entries(query)) {\n\t\tif ('eq' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tconst ids = index.get().get(matcher.eq)\n\t\t\tif (ids) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('neq' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tfor (const [value, ids] of index.get()) {\n\t\t\t\tif (value !== matcher.neq) {\n\t\t\t\t\tfor (const id of ids) {\n\t\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('gt' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tfor (const [value, ids] of index.get()) {\n\t\t\t\tif (value > matcher.gt) {\n\t\t\t\t\tfor (const id of ids) {\n\t\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intersectSets(Object.values(matchIds)) as Set<IdOf<Extract<R, { typeName: TypeName }>>>\n}\n"],
  "mappings": "AACA,SAAS,qBAAqB;AAkEvB,SAAS,mBAAqC,OAA2B,QAAW;AAC1F,aAAW,CAAC,KAAK,QAAQ,KAAK,OAAO,QAAQ,KAAK,GAAG;AACpD,UAAM,UAAU;AAChB,UAAM,QAAQ,OAAO,GAAc;AAInC,QAAI,QAAQ,WAAW,UAAU,QAAQ,GAAI,QAAO;AACpD,QAAI,SAAS,WAAW,UAAU,QAAQ,IAAK,QAAO;AACtD,QAAI,QAAQ,YAAY,OAAO,UAAU,YAAY,SAAS,QAAQ,IAAK,QAAO;AAAA,EACnF;AACA,SAAO;AACR;AA2BO,SAAS,aACf,OACA,UACA,OACgD;AAChD,QAAM,WAAW,OAAO,YAAY,OAAO,KAAK,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,oBAAI,IAAI,CAAC,CAAC,CAAC;AAErF,aAAW,CAAC,GAAG,OAAO,KAAK,OAAO,QAAQ,KAAK,GAAG;AACjD,QAAI,QAAQ,SAAS;AACpB,YAAM,QAAQ,MAAM,MAAM,UAAU,CAAQ;AAC5C,YAAM,MAAM,MAAM,IAAI,EAAE,IAAI,QAAQ,EAAE;AACtC,UAAI,KAAK;AACR,mBAAW,MAAM,KAAK;AACrB,mBAAS,CAAC,EAAE,IAAI,EAAE;AAAA,QACnB;AAAA,MACD;AAAA,IACD,WAAW,SAAS,SAAS;AAC5B,YAAM,QAAQ,MAAM,MAAM,UAAU,CAAQ;AAC5C,iBAAW,CAAC,OAAO,GAAG,KAAK,MAAM,IAAI,GAAG;AACvC,YAAI,UAAU,QAAQ,KAAK;AAC1B,qBAAW,MAAM,KAAK;AACrB,qBAAS,CAAC,EAAE,IAAI,EAAE;AAAA,UACnB;AAAA,QACD;AAAA,MACD;AAAA,IACD,WAAW,QAAQ,SAAS;AAC3B,YAAM,QAAQ,MAAM,MAAM,UAAU,CAAQ;AAC5C,iBAAW,CAAC,OAAO,GAAG,KAAK,MAAM,IAAI,GAAG;AACvC,YAAI,QAAQ,QAAQ,IAAI;AACvB,qBAAW,MAAM,KAAK;AACrB,qBAAS,CAAC,EAAE,IAAI,EAAE;AAAA,UACnB;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,SAAO,cAAc,OAAO,OAAO,QAAQ,CAAC;AAC7C;",
  "names": []
}
