{
  "version": 3,
  "sources": ["../../../../src/lib/editor/derivations/parentsToChildren.ts"],
  "sourcesContent": ["import { Computed, computed, isUninitialized, RESET_VALUE } from '@tldraw/state'\nimport { CollectionDiff, RecordsDiff } from '@tldraw/store'\nimport { isShape, TLParentId, TLRecord, TLShape, TLShapeId, TLStore } from '@tldraw/tlschema'\nimport { compact, sortByIndex } from '@tldraw/utils'\n\ntype ParentShapeIdsToChildShapeIds = Record<TLParentId, TLShapeId[]>\n\nfunction fromScratch(\n\tshapeIdsQuery: Computed<Set<TLShapeId>, CollectionDiff<TLShapeId>>,\n\tstore: TLStore\n) {\n\tconst result: ParentShapeIdsToChildShapeIds = {}\n\tconst shapeIds = shapeIdsQuery.get()\n\tconst shapes = Array(shapeIds.size) as TLShape[]\n\tshapeIds.forEach((id) => shapes.push(store.get(id)!))\n\n\t// Sort the shapes by index\n\tshapes.sort(sortByIndex)\n\n\t// Populate the result object with an array for each parent.\n\tshapes.forEach((shape) => {\n\t\tif (!result[shape.parentId]) {\n\t\t\tresult[shape.parentId] = []\n\t\t}\n\t\tresult[shape.parentId].push(shape.id)\n\t})\n\n\treturn result\n}\n\nexport const parentsToChildren = (store: TLStore) => {\n\tconst shapeIdsQuery = store.query.ids<'shape'>('shape')\n\tconst shapeHistory = store.query.filterHistory('shape')\n\n\treturn computed<ParentShapeIdsToChildShapeIds>(\n\t\t'parentsToChildrenWithIndexes',\n\t\t(lastValue, lastComputedEpoch) => {\n\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\treturn fromScratch(shapeIdsQuery, store)\n\t\t\t}\n\n\t\t\tconst diff = shapeHistory.getDiffSince(lastComputedEpoch)\n\n\t\t\tif (diff === RESET_VALUE) {\n\t\t\t\treturn fromScratch(shapeIdsQuery, store)\n\t\t\t}\n\n\t\t\tif (diff.length === 0) return lastValue\n\n\t\t\tlet newValue: Record<TLParentId, TLShapeId[]> | null = null\n\n\t\t\tconst ensureNewArray = (parentId: TLParentId) => {\n\t\t\t\tif (!newValue) {\n\t\t\t\t\tnewValue = { ...lastValue }\n\t\t\t\t}\n\t\t\t\tif (!newValue[parentId]) {\n\t\t\t\t\tnewValue[parentId] = []\n\t\t\t\t} else if (newValue[parentId] === lastValue[parentId]) {\n\t\t\t\t\tnewValue[parentId] = [...newValue[parentId]!]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst toSort = new Set<TLShapeId[]>()\n\n\t\t\tlet changes: RecordsDiff<TLRecord>\n\n\t\t\tfor (let i = 0, n = diff.length; i < n; i++) {\n\t\t\t\tchanges = diff[i]\n\n\t\t\t\t// Iterate through the added shapes, add them to the new value and mark them for sorting\n\t\t\t\tfor (const record of Object.values(changes.added)) {\n\t\t\t\t\tif (!isShape(record)) continue\n\t\t\t\t\tensureNewArray(record.parentId)\n\t\t\t\t\tnewValue![record.parentId].push(record.id)\n\t\t\t\t\ttoSort.add(newValue![record.parentId])\n\t\t\t\t}\n\n\t\t\t\t// Iterate through the updated shapes, add them to their parents in the new value and mark them for sorting\n\t\t\t\tfor (const [from, to] of Object.values(changes.updated)) {\n\t\t\t\t\tif (!isShape(to)) continue\n\t\t\t\t\tif (!isShape(from)) continue\n\n\t\t\t\t\tif (from.parentId !== to.parentId) {\n\t\t\t\t\t\t// If the parents have changed, remove the new value from the old parent and add it to the new parent\n\t\t\t\t\t\tensureNewArray(from.parentId)\n\t\t\t\t\t\tensureNewArray(to.parentId)\n\t\t\t\t\t\tnewValue![from.parentId].splice(newValue![from.parentId].indexOf(to.id), 1)\n\t\t\t\t\t\tnewValue![to.parentId].push(to.id)\n\t\t\t\t\t\ttoSort.add(newValue![to.parentId])\n\t\t\t\t\t} else if (from.index !== to.index) {\n\t\t\t\t\t\t// If the parent is the same but the index has changed (e.g. if they've been reordered), update the parent's array at the new index\n\t\t\t\t\t\tensureNewArray(to.parentId)\n\t\t\t\t\t\tconst idx = newValue![to.parentId].indexOf(to.id)\n\t\t\t\t\t\tnewValue![to.parentId][idx] = to.id\n\t\t\t\t\t\ttoSort.add(newValue![to.parentId])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Iterate through the removed shapes, remove them from their parents in new value\n\t\t\t\tfor (const record of Object.values(changes.removed)) {\n\t\t\t\t\tif (!isShape(record)) continue\n\t\t\t\t\tensureNewArray(record.parentId)\n\t\t\t\t\tnewValue![record.parentId].splice(newValue![record.parentId].indexOf(record.id), 1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort the arrays that have been marked for sorting\n\t\t\tfor (const arr of toSort) {\n\t\t\t\t// It's possible that some of the shapes may be deleted. But in which case would this be so?\n\t\t\t\tconst shapesInArr = compact(arr.map((id) => store.get(id)))\n\t\t\t\tshapesInArr.sort(sortByIndex)\n\t\t\t\tarr.splice(0, arr.length, ...shapesInArr.map((shape) => shape.id))\n\t\t\t}\n\n\t\t\treturn newValue ?? lastValue\n\t\t}\n\t)\n}\n"],
  "mappings": "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",
  "names": []
}
