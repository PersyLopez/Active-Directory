{
  "version": 3,
  "sources": ["../../src/lib/value.ts"],
  "sourcesContent": ["/**\n * Get whether a value is not undefined.\n *\n * @param value - The value to check.\n * @returns True if the value is not undefined, with proper type narrowing.\n * @example\n * ```ts\n * const maybeString: string | undefined = getValue()\n *\n * if (isDefined(maybeString)) {\n *   // TypeScript knows maybeString is string, not undefined\n *   console.log(maybeString.toUpperCase())\n * }\n *\n * // Filter undefined values from arrays\n * const values = [1, undefined, 2, undefined, 3]\n * const definedValues = values.filter(isDefined) // [1, 2, 3]\n * ```\n * @public\n */\nexport function isDefined<T>(value: T): value is typeof value extends undefined ? never : T {\n\treturn value !== undefined\n}\n\n/**\n * Get whether a value is not null.\n *\n * @param value - The value to check.\n * @returns True if the value is not null, with proper type narrowing.\n * @example\n * ```ts\n * const maybeString: string | null = getValue()\n *\n * if (isNonNull(maybeString)) {\n *   // TypeScript knows maybeString is string, not null\n *   console.log(maybeString.length)\n * }\n *\n * // Filter null values from arrays\n * const values = [\"a\", null, \"b\", null, \"c\"]\n * const nonNullValues = values.filter(isNonNull) // [\"a\", \"b\", \"c\"]\n * ```\n * @public\n */\nexport function isNonNull<T>(value: T): value is typeof value extends null ? never : T {\n\treturn value !== null\n}\n\n/**\n * Get whether a value is not nullish (not null and not undefined).\n *\n * @param value - The value to check.\n * @returns True if the value is neither null nor undefined, with proper type narrowing.\n * @example\n * ```ts\n * const maybeString: string | null | undefined = getValue()\n *\n * if (isNonNullish(maybeString)) {\n *   // TypeScript knows maybeString is string, not null or undefined\n *   console.log(maybeString.charAt(0))\n * }\n *\n * // Filter nullish values from arrays\n * const values = [\"hello\", null, \"world\", undefined, \"!\"]\n * const cleanValues = values.filter(isNonNullish) // [\"hello\", \"world\", \"!\"]\n * ```\n * @public\n */\nexport function isNonNullish<T>(\n\tvalue: T\n): value is typeof value extends undefined ? never : typeof value extends null ? never : T {\n\treturn value !== null && value !== undefined\n}\n\nfunction getStructuredClone(): [<T>(i: T) => T, boolean] {\n\tif (typeof globalThis !== 'undefined' && (globalThis as any).structuredClone) {\n\t\treturn [globalThis.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof global !== 'undefined' && (global as any).structuredClone) {\n\t\treturn [global.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof window !== 'undefined' && (window as any).structuredClone) {\n\t\treturn [window.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\treturn [<T>(i: T): T => (i ? JSON.parse(JSON.stringify(i)) : i), false]\n}\n\nconst _structuredClone = getStructuredClone()\n\n/**\n * Create a deep copy of a value. Uses the structuredClone API if available, otherwise uses JSON.parse(JSON.stringify()).\n *\n * @param i - The value to clone.\n * @returns A deep copy of the input value.\n * @example\n * ```ts\n * const original = { a: 1, b: { c: 2 } }\n * const copy = structuredClone(original)\n *\n * copy.b.c = 3\n * console.log(original.b.c) // 2 (unchanged)\n * console.log(copy.b.c) // 3\n *\n * // Works with complex objects\n * const complexObject = {\n *   date: new Date(),\n *   array: [1, 2, 3],\n *   nested: { deep: { value: \"test\" } }\n * }\n * const cloned = structuredClone(complexObject)\n * ```\n * @public\n */\nexport const structuredClone = _structuredClone[0]\n\n/**\n * Whether the current environment has native structuredClone support.\n * @returns True if using native structuredClone, false if using JSON fallback.\n * @internal\n */\nexport const isNativeStructuredClone = _structuredClone[1]\n\n/**\n * The prototype object used by structuredClone for cloned objects.\n * When we patch structuredClone in jsdom for testing (see https://github.com/jsdom/jsdom/issues/3363),\n * the Object that is used as a prototype for the cloned object is not the same as the Object in\n * the code under test (that comes from jsdom's fake global context). This constant is used in\n * our code to work around this case.\n *\n * This is also the case for Array prototype, but that problem can be worked around with an\n * Array.isArray() check.\n * @internal\n */\nexport const STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}))\n"],
  "mappings": "AAoBO,SAAS,UAAa,OAA+D;AAC3F,SAAO,UAAU;AAClB;AAsBO,SAAS,UAAa,OAA0D;AACtF,SAAO,UAAU;AAClB;AAsBO,SAAS,aACf,OAC0F;AAC1F,SAAO,UAAU,QAAQ,UAAU;AACpC;AAEA,SAAS,qBAAgD;AACxD,MAAI,OAAO,eAAe,eAAgB,WAAmB,iBAAiB;AAC7E,WAAO,CAAC,WAAW,iBAAmC,IAAI;AAAA,EAC3D;AAEA,MAAI,OAAO,WAAW,eAAgB,OAAe,iBAAiB;AACrE,WAAO,CAAC,OAAO,iBAAmC,IAAI;AAAA,EACvD;AAEA,MAAI,OAAO,WAAW,eAAgB,OAAe,iBAAiB;AACrE,WAAO,CAAC,OAAO,iBAAmC,IAAI;AAAA,EACvD;AAEA,SAAO,CAAC,CAAI,MAAa,IAAI,KAAK,MAAM,KAAK,UAAU,CAAC,CAAC,IAAI,GAAI,KAAK;AACvE;AAEA,MAAM,mBAAmB,mBAAmB;AA0BrC,MAAM,kBAAkB,iBAAiB,CAAC;AAO1C,MAAM,0BAA0B,iBAAiB,CAAC;AAalD,MAAM,oCAAoC,OAAO,eAAe,gBAAgB,CAAC,CAAC,CAAC;",
  "names": []
}
