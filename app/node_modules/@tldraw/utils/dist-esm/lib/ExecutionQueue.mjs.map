{
  "version": 3,
  "sources": ["../../src/lib/ExecutionQueue.ts"],
  "sourcesContent": ["import { sleep } from './control'\n\n/**\n * A queue that executes tasks sequentially with optional delay between tasks.\n *\n * ExecutionQueue ensures that tasks are executed one at a time in the order they were added,\n * with an optional timeout delay between each task execution. This is useful for rate limiting,\n * preventing race conditions, or controlling the flow of asynchronous operations.\n *\n * @example\n * ```ts\n * // Create a queue with 100ms delay between tasks\n * const queue = new ExecutionQueue(100)\n *\n * // Add tasks to the queue\n * const result1 = await queue.push(() => fetch('/api/data'))\n * const result2 = await queue.push(async () => {\n *   const data = await processData()\n *   return data\n * })\n *\n * // Check if queue is empty\n * if (queue.isEmpty()) {\n *   console.log('All tasks completed')\n * }\n *\n * // Clean up\n * queue.close()\n * ```\n *\n * @internal\n */\nexport class ExecutionQueue {\n\tprivate queue: (() => Promise<any>)[] = []\n\tprivate running = false\n\n\t/**\n\t * Creates a new ExecutionQueue.\n\t *\n\t * Creates a new execution queue that will process tasks sequentially.\n\t * If a timeout is provided, there will be a delay between each task execution,\n\t * which is useful for rate limiting or controlling execution flow.\n\t *\n\t * timeout - Optional delay in milliseconds between task executions\n\t * @example\n\t * ```ts\n\t * // Create queue without delay\n\t * const fastQueue = new ExecutionQueue()\n\t *\n\t * // Create queue with 500ms delay between tasks\n\t * const slowQueue = new ExecutionQueue(500)\n\t * ```\n\t */\n\tconstructor(private readonly timeout?: number) {}\n\n\t/**\n\t * Checks if the queue is empty and not currently running a task.\n\t *\n\t * Determines whether the execution queue has completed all tasks and is idle.\n\t * Returns true only when there are no pending tasks in the queue AND no task is currently being executed.\n\t *\n\t * @returns True if the queue has no pending tasks and is not currently executing\n\t * @example\n\t * ```ts\n\t * const queue = new ExecutionQueue()\n\t *\n\t * console.log(queue.isEmpty()) // true - queue is empty\n\t *\n\t * queue.push(() => console.log('task'))\n\t * console.log(queue.isEmpty()) // false - task is running/pending\n\t * ```\n\t */\n\tisEmpty() {\n\t\treturn this.queue.length === 0 && !this.running\n\t}\n\n\tprivate async run() {\n\t\tif (this.running) return\n\t\ttry {\n\t\t\tthis.running = true\n\t\t\twhile (this.queue.length) {\n\t\t\t\tconst task = this.queue.shift()!\n\t\t\t\tawait task()\n\t\t\t\tif (this.timeout) {\n\t\t\t\t\tawait sleep(this.timeout)\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\t// this try/finally should not be needed because the tasks don't throw\n\t\t\t// but better safe than sorry\n\t\t\t// console.log('\\n\\n\\nrunning false\\n\\n\\n')\n\t\t\tthis.running = false\n\t\t}\n\t}\n\n\t/**\n\t * Adds a task to the queue and returns a promise that resolves with the task's result.\n\t *\n\t * Enqueues a task for sequential execution. The task will be executed after all\n\t * previously queued tasks have completed. If a timeout was specified in the constructor,\n\t * there will be a delay between this task and the next one.\n\t *\n\t * @param task - The function to execute (can be sync or async)\n\t * @returns Promise that resolves with the task's return value\n\t * @example\n\t * ```ts\n\t * const queue = new ExecutionQueue(100)\n\t *\n\t * // Add async task\n\t * const result = await queue.push(async () => {\n\t *   const response = await fetch('/api/data')\n\t *   return response.json()\n\t * })\n\t *\n\t * // Add sync task\n\t * const number = await queue.push(() => 42)\n\t * ```\n\t */\n\tasync push<T>(task: () => T): Promise<Awaited<T>> {\n\t\treturn new Promise<Awaited<T>>((resolve, reject) => {\n\t\t\tthis.queue.push(() => Promise.resolve(task()).then(resolve).catch(reject))\n\t\t\tthis.run()\n\t\t})\n\t}\n\n\t/**\n\t * Clears all pending tasks from the queue.\n\t *\n\t * Immediately removes all pending tasks from the queue. Any currently\n\t * running task will complete normally, but no additional tasks will be executed.\n\t * This method does not wait for the current task to finish.\n\t *\n\t * @returns void\n\t * @example\n\t * ```ts\n\t * const queue = new ExecutionQueue()\n\t *\n\t * // Add several tasks\n\t * queue.push(() => console.log('task 1'))\n\t * queue.push(() => console.log('task 2'))\n\t * queue.push(() => console.log('task 3'))\n\t *\n\t * // Clear all pending tasks\n\t * queue.close()\n\t * // Only 'task 1' will execute if it was already running\n\t * ```\n\t */\n\tclose() {\n\t\tthis.queue = []\n\t}\n}\n"],
  "mappings": "AAAA,SAAS,aAAa;AAgCf,MAAM,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqB3B,YAA6B,SAAkB;AAAlB;AAAA,EAAmB;AAAA,EApBxC,QAAgC,CAAC;AAAA,EACjC,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsClB,UAAU;AACT,WAAO,KAAK,MAAM,WAAW,KAAK,CAAC,KAAK;AAAA,EACzC;AAAA,EAEA,MAAc,MAAM;AACnB,QAAI,KAAK,QAAS;AAClB,QAAI;AACH,WAAK,UAAU;AACf,aAAO,KAAK,MAAM,QAAQ;AACzB,cAAM,OAAO,KAAK,MAAM,MAAM;AAC9B,cAAM,KAAK;AACX,YAAI,KAAK,SAAS;AACjB,gBAAM,MAAM,KAAK,OAAO;AAAA,QACzB;AAAA,MACD;AAAA,IACD,UAAE;AAID,WAAK,UAAU;AAAA,IAChB;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,MAAM,KAAQ,MAAoC;AACjD,WAAO,IAAI,QAAoB,CAAC,SAAS,WAAW;AACnD,WAAK,MAAM,KAAK,MAAM,QAAQ,QAAQ,KAAK,CAAC,EAAE,KAAK,OAAO,EAAE,MAAM,MAAM,CAAC;AACzE,WAAK,IAAI;AAAA,IACV,CAAC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,QAAQ;AACP,SAAK,QAAQ,CAAC;AAAA,EACf;AACD;",
  "names": []
}
