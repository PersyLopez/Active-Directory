{
  "version": 3,
  "sources": ["../../src/lib/number.ts"],
  "sourcesContent": ["/**\n * Linear interpolate between two values.\n *\n * @param a - The start value\n * @param b - The end value\n * @param t - The interpolation factor (0-1)\n * @returns The interpolated value\n * @example\n * ```ts\n * const halfway = lerp(0, 100, 0.5) // 50\n * const quarter = lerp(10, 20, 0.25) // 12.5\n * ```\n * @public\n */\nexport function lerp(a: number, b: number, t: number) {\n\treturn a + (b - a) * t\n}\n\n/**\n * Inverse lerp between two values. Given a value `t` in the range [a, b], returns a number between\n * 0 and 1.\n *\n * @param a - The start value of the range\n * @param b - The end value of the range\n * @param t - The value within the range [a, b]\n * @returns The normalized position (0-1) of t within the range [a, b]\n * @example\n * ```ts\n * const position = invLerp(0, 100, 25) // 0.25\n * const normalized = invLerp(10, 20, 15) // 0.5\n * ```\n * @public\n */\nexport function invLerp(a: number, b: number, t: number) {\n\treturn (t - a) / (b - a)\n}\n\n/**\n * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift). The\n * result will always be between -1 and 1.\n *\n * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).\n *\n * @param seed - The seed string for deterministic random generation (defaults to empty string)\n * @returns A function that will return a random number between -1 and 1 each time it is called\n * @example\n * ```ts\n * const random = rng('my-seed')\n * const num1 = random() // Always the same for this seed\n * const num2 = random() // Next number in sequence\n *\n * // Different seed produces different sequence\n * const otherRandom = rng('other-seed')\n * const different = otherRandom() // Different value\n * ```\n * @public\n */\nexport function rng(seed = '') {\n\tlet x = 0\n\tlet y = 0\n\tlet z = 0\n\tlet w = 0\n\n\tfunction next() {\n\t\tconst t = x ^ (x << 11)\n\t\tx = y\n\t\ty = z\n\t\tz = w\n\t\tw ^= ((w >>> 19) ^ t ^ (t >>> 8)) >>> 0\n\t\treturn (w / 0x100000000) * 2\n\t}\n\n\tfor (let k = 0; k < seed.length + 64; k++) {\n\t\tx ^= seed.charCodeAt(k) | 0\n\t\tnext()\n\t}\n\n\treturn next\n}\n\n/**\n * Modulate a value between two ranges.\n *\n * @example\n *\n * ```ts\n * const A = modulate(0, [0, 1], [0, 100])\n * ```\n *\n * @param value - The interpolation value.\n * @param rangeA - From [low, high]\n * @param rangeB - To [low, high]\n * @param clamp - Whether to clamp the the result to [low, high]\n * @public\n */\nexport function modulate(value: number, rangeA: number[], rangeB: number[], clamp = false): number {\n\tconst [fromLow, fromHigh] = rangeA\n\tconst [v0, v1] = rangeB\n\tconst result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)\n\n\treturn clamp\n\t\t? v0 < v1\n\t\t\t? Math.max(Math.min(result, v1), v0)\n\t\t\t: Math.max(Math.min(result, v0), v1)\n\t\t: result\n}\n"],
  "mappings": "AAcO,SAAS,KAAK,GAAW,GAAW,GAAW;AACrD,SAAO,KAAK,IAAI,KAAK;AACtB;AAiBO,SAAS,QAAQ,GAAW,GAAW,GAAW;AACxD,UAAQ,IAAI,MAAM,IAAI;AACvB;AAsBO,SAAS,IAAI,OAAO,IAAI;AAC9B,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,IAAI;AAER,WAAS,OAAO;AACf,UAAM,IAAI,IAAK,KAAK;AACpB,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,UAAO,MAAM,KAAM,IAAK,MAAM,OAAQ;AACtC,WAAQ,IAAI,aAAe;AAAA,EAC5B;AAEA,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,IAAI,KAAK;AAC1C,SAAK,KAAK,WAAW,CAAC,IAAI;AAC1B,SAAK;AAAA,EACN;AAEA,SAAO;AACR;AAiBO,SAAS,SAAS,OAAe,QAAkB,QAAkB,QAAQ,OAAe;AAClG,QAAM,CAAC,SAAS,QAAQ,IAAI;AAC5B,QAAM,CAAC,IAAI,EAAE,IAAI;AACjB,QAAM,SAAS,MAAO,QAAQ,YAAY,WAAW,YAAa,KAAK;AAEvE,SAAO,QACJ,KAAK,KACJ,KAAK,IAAI,KAAK,IAAI,QAAQ,EAAE,GAAG,EAAE,IACjC,KAAK,IAAI,KAAK,IAAI,QAAQ,EAAE,GAAG,EAAE,IAClC;AACJ;",
  "names": []
}
