{
  "version": 3,
  "sources": ["../../src/lib/types.ts"],
  "sourcesContent": ["/**\n * Makes all properties in a type and all nested properties optional recursively.\n * This is useful for creating partial update objects where you only want to specify\n * some deeply nested properties while leaving others unchanged.\n *\n * @example\n * ```ts\n * interface User {\n *   name: string\n *   settings: {\n *     theme: string\n *     notifications: {\n *       email: boolean\n *       push: boolean\n *     }\n *   }\n * }\n *\n * type PartialUser = RecursivePartial<User>\n * // Result: {\n * //   name?: string\n * //   settings?: {\n * //     theme?: string\n * //     notifications?: {\n * //       email?: boolean\n * //       push?: boolean\n * //     }\n * //   }\n * // }\n *\n * const update: PartialUser = {\n *   settings: {\n *     notifications: {\n *       email: false\n *     }\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?: RecursivePartial<T[P]>\n}\n\n/**\n * Expands a type definition to show its full structure in IDE tooltips and error messages.\n * This utility type forces TypeScript to resolve and display the complete type structure\n * instead of showing complex conditional types or intersections as-is.\n *\n * @example\n * ```ts\n * type User = { name: string }\n * type WithId = { id: string }\n * type UserWithId = User & WithId\n *\n * // Without Expand, IDE shows: User & WithId\n * // With Expand, IDE shows: { name: string; id: string }\n * type ExpandedUserWithId = Expand<UserWithId>\n *\n * // Useful for complex intersections\n * type ComplexType = Expand<BaseType & Mixin1 & Mixin2>\n * ```\n *\n * @public\n */\nexport type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never\n\n/**\n * Makes specified keys in a type required while keeping all other properties as-is.\n * This is useful when you need to ensure certain optional properties are provided\n * in specific contexts without affecting the entire type structure.\n *\n * @example\n * ```ts\n * interface Shape {\n *   id: string\n *   x?: number\n *   y?: number\n *   visible?: boolean\n * }\n *\n * // Make position properties required\n * type PositionedShape = Required<Shape, 'x' | 'y'>\n * // Result: {\n * //   id: string\n * //   x: number      // now required\n * //   y: number      // now required\n * //   visible?: boolean\n * // }\n *\n * const shape: PositionedShape = {\n *   id: 'rect1',\n *   x: 10,    // must provide\n *   y: 20,    // must provide\n *   // visible is still optional\n * }\n * ```\n *\n * @internal\n */\nexport type Required<T, K extends keyof T> = Expand<Omit<T, K> & { [P in K]-?: T[P] }>\n\n/**\n * Automatically makes properties optional if their type includes `undefined`.\n * This transforms properties like `prop: string | undefined` to `prop?: string | undefined`,\n * making the API more ergonomic by not requiring explicit undefined assignments.\n *\n * @example\n * ```ts\n * interface RawConfig {\n *   name: string\n *   theme: string | undefined\n *   debug: boolean | undefined\n *   version: number\n * }\n *\n * type Config = MakeUndefinedOptional<RawConfig>\n * // Result: {\n * //   name: string\n * //   theme?: string | undefined    // now optional\n * //   debug?: boolean | undefined   // now optional\n * //   version: number\n * // }\n *\n * const config: Config = {\n *   name: 'MyApp',\n *   version: 1\n *   // theme and debug can be omitted instead of explicitly set to undefined\n * }\n * ```\n *\n * @public\n */\nexport type MakeUndefinedOptional<T extends object> = Expand<\n\t{\n\t\t[P in { [K in keyof T]: undefined extends T[K] ? never : K }[keyof T]]: T[P]\n\t} & {\n\t\t[P in { [K in keyof T]: undefined extends T[K] ? K : never }[keyof T]]?: T[P]\n\t}\n>\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
