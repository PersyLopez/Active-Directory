{
  "version": 3,
  "sources": ["../../src/bindings/TLBaseBinding.ts"],
  "sourcesContent": ["import { BaseRecord } from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { TLBindingId } from '../records/TLBinding'\nimport { TLShapeId } from '../records/TLShape'\nimport { shapeIdValidator } from '../shapes/TLBaseShape'\n\n/**\n * Base interface for all binding types in tldraw. Bindings represent relationships\n * between shapes, such as arrows connecting to other shapes or organizational connections.\n *\n * All bindings extend this base interface with specific type and property definitions.\n * The binding system enables shapes to maintain relationships that persist through\n * transformations, movements, and other operations.\n *\n * @param Type - String literal type identifying the specific binding type (e.g., 'arrow')\n * @param Props - Object containing binding-specific properties and configuration\n *\n * @example\n * ```ts\n * // Define a custom binding type\n * interface MyCustomBinding extends TLBaseBinding<'custom', MyCustomProps> {}\n *\n * interface MyCustomProps {\n *   strength: number\n *   color: string\n * }\n *\n * // Create a binding instance\n * const binding: MyCustomBinding = {\n *   id: 'binding:abc123',\n *   typeName: 'binding',\n *   type: 'custom',\n *   fromId: 'shape:source1',\n *   toId: 'shape:target1',\n *   props: {\n *     strength: 0.8,\n *     color: 'red'\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport interface TLBaseBinding<Type extends string, Props extends object>\n\textends BaseRecord<'binding', TLBindingId> {\n\t/** The specific type of this binding (e.g., 'arrow', 'custom') */\n\ttype: Type\n\t/** ID of the source shape in this binding relationship */\n\tfromId: TLShapeId\n\t/** ID of the target shape in this binding relationship */\n\ttoId: TLShapeId\n\t/** Binding-specific properties that define behavior and appearance */\n\tprops: Props\n\t/** User-defined metadata for extending binding functionality */\n\tmeta: JsonObject\n}\n\n/**\n * Validator for binding IDs. Ensures that binding identifiers follow the correct\n * format and type constraints required by the tldraw schema system.\n *\n * Used internally by the schema validation system to verify binding IDs when\n * records are created or modified. All binding IDs must be prefixed with 'binding:'.\n *\n * @example\n * ```ts\n * import { bindingIdValidator } from '@tldraw/tlschema'\n *\n * // Validate a binding ID\n * const isValid = bindingIdValidator.isValid('binding:abc123') // true\n * const isInvalid = bindingIdValidator.isValid('shape:abc123') // false\n *\n * // Use in custom validation schema\n * const customBindingValidator = T.object({\n *   id: bindingIdValidator,\n *   // ... other properties\n * })\n * ```\n *\n * @public\n */\nexport const bindingIdValidator = idValidator<TLBindingId>('binding')\n\n/**\n * Creates a runtime validator for a specific binding type. This factory function\n * generates a complete validation schema for custom bindings that extends TLBaseBinding.\n *\n * The validator ensures all binding records conform to the expected structure with\n * proper type safety and runtime validation. It validates the base binding properties\n * (id, type, fromId, toId) along with custom props and meta fields.\n *\n * @param type - The string literal type identifier for this binding (e.g., 'arrow', 'custom')\n * @param props - Optional validation schema for binding-specific properties\n * @param meta - Optional validation schema for metadata fields\n *\n * @returns A validator object that can validate complete binding records\n *\n * @example\n * ```ts\n * import { createBindingValidator } from '@tldraw/tlschema'\n * import { T } from '@tldraw/validate'\n *\n * // Create validator for a custom binding type\n * const myBindingValidator = createBindingValidator(\n *   'myBinding',\n *   {\n *     strength: T.number,\n *     color: T.string,\n *     enabled: T.boolean\n *   },\n *   {\n *     createdAt: T.number,\n *     author: T.string\n *   }\n * )\n *\n * // Validate a binding instance\n * const bindingData = {\n *   id: 'binding:123',\n *   typeName: 'binding',\n *   type: 'myBinding',\n *   fromId: 'shape:abc',\n *   toId: 'shape:def',\n *   props: {\n *     strength: 0.8,\n *     color: 'red',\n *     enabled: true\n *   },\n *   meta: {\n *     createdAt: Date.now(),\n *     author: 'user123'\n *   }\n * }\n *\n * const isValid = myBindingValidator.isValid(bindingData) // true\n * ```\n *\n * @example\n * ```ts\n * // Simple binding without custom props or meta\n * const simpleBindingValidator = createBindingValidator('simple')\n *\n * // This will use JsonValue validation for props and meta\n * const binding = {\n *   id: 'binding:456',\n *   typeName: 'binding',\n *   type: 'simple',\n *   fromId: 'shape:start',\n *   toId: 'shape:end',\n *   props: {}, // Any JSON value allowed\n *   meta: {}   // Any JSON value allowed\n * }\n * ```\n *\n * @public\n */\nexport function createBindingValidator<\n\tType extends string,\n\tProps extends JsonObject,\n\tMeta extends JsonObject,\n>(\n\ttype: Type,\n\tprops?: { [K in keyof Props]: T.Validatable<Props[K]> },\n\tmeta?: { [K in keyof Meta]: T.Validatable<Meta[K]> }\n) {\n\treturn T.object<TLBaseBinding<Type, Props>>({\n\t\tid: bindingIdValidator,\n\t\ttypeName: T.literal('binding'),\n\t\ttype: T.literal(type),\n\t\tfromId: shapeIdValidator,\n\t\ttoId: shapeIdValidator,\n\t\tprops: props ? T.object(props) : (T.jsonValue as any),\n\t\tmeta: meta ? T.object(meta) : (T.jsonValue as any),\n\t})\n}\n"],
  "mappings": "AAEA,SAAS,SAAS;AAClB,SAAS,mBAAmB;AAG5B,SAAS,wBAAwB;AA8E1B,MAAM,qBAAqB,YAAyB,SAAS;AA2E7D,SAAS,uBAKf,MACA,OACA,MACC;AACD,SAAO,EAAE,OAAmC;AAAA,IAC3C,IAAI;AAAA,IACJ,UAAU,EAAE,QAAQ,SAAS;AAAA,IAC7B,MAAM,EAAE,QAAQ,IAAI;AAAA,IACpB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,OAAO,QAAQ,EAAE,OAAO,KAAK,IAAK,EAAE;AAAA,IACpC,MAAM,OAAO,EAAE,OAAO,IAAI,IAAK,EAAE;AAAA,EAClC,CAAC;AACF;",
  "names": []
}
