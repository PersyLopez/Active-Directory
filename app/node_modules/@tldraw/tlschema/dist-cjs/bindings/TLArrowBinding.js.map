{
  "version": 3,
  "sources": ["../../src/bindings/TLArrowBinding.ts"],
  "sourcesContent": ["import { T } from '@tldraw/validate'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport {\n\tcreateBindingPropsMigrationIds,\n\tcreateBindingPropsMigrationSequence,\n} from '../records/TLBinding'\nimport { RecordProps } from '../recordsWithProps'\nimport { arrowShapeVersions } from '../shapes/TLArrowShape'\nimport { TLBaseBinding } from './TLBaseBinding'\n\n/**\n * Defines the snapping behavior for elbow-style arrows when binding to shapes.\n * Controls how the arrow segment aligns with the target shape's geometry.\n *\n * @example\n * ```ts\n * const binding: TLArrowBindingProps = {\n *   terminal: 'end',\n *   normalizedAnchor: { x: 0.5, y: 0.5 },\n *   isExact: false,\n *   isPrecise: true,\n *   snap: 'edge' // Snap to shape edge\n * }\n * ```\n *\n * @public\n */\nexport const ElbowArrowSnap = T.literalEnum('center', 'edge-point', 'edge', 'none')\n/**\n * Type representing the possible elbow arrow snap modes.\n *\n * - `'center'` - Snap to the center of the target shape\n * - `'edge-point'` - Snap to a specific point on the shape's edge\n * - `'edge'` - Snap to the nearest edge of the shape\n * - `'none'` - No snapping behavior\n *\n * @public\n */\nexport type ElbowArrowSnap = T.TypeOf<typeof ElbowArrowSnap>\n\n/**\n * Properties that define how an arrow binds to a target shape.\n * These properties control the visual and behavioral aspects of the arrow-to-shape connection.\n *\n * @example\n * ```ts\n * const arrowBindingProps: TLArrowBindingProps = {\n *   terminal: 'end', // Bind the arrow's end point\n *   normalizedAnchor: { x: 0.5, y: 0.0 }, // Bind to top center of shape\n *   isExact: true, // Arrow head enters the shape\n *   isPrecise: true, // Use exact anchor position\n *   snap: 'edge' // Snap to shape edge\n * }\n * ```\n *\n * @public\n */\nexport interface TLArrowBindingProps {\n\t/** Which end of the arrow is bound - either 'start' or 'end' */\n\tterminal: 'start' | 'end'\n\t/**\n\t * Normalized anchor point on the target shape (0,0 = top-left, 1,1 = bottom-right).\n\t * Coordinates are relative to the shape's bounding box.\n\t */\n\tnormalizedAnchor: VecModel\n\t/**\n\t * Whether the arrow head 'enters' the bound shape to point directly at the binding\n\t * anchor point. When true, the arrow head will be positioned inside the target shape.\n\t */\n\tisExact: boolean\n\t/**\n\t * Whether to bind to the exact normalizedAnchor position, or to the center of the shape.\n\t * When false, the arrow will connect to the shape's center regardless of anchor position.\n\t */\n\tisPrecise: boolean\n\t/** Snapping behavior for elbow-style arrows */\n\tsnap: ElbowArrowSnap\n}\n\n/**\n * Validation schema for arrow binding properties.\n * Defines the runtime validation rules for each property in TLArrowBindingProps.\n *\n * @example\n * ```ts\n * import { arrowBindingProps } from '@tldraw/tlschema'\n *\n * // Use in custom shape schema\n * const customSchema = createTLSchema({\n *   bindings: {\n *     arrow: {\n *       props: arrowBindingProps,\n *       migrations: arrowBindingMigrations\n *     }\n *   }\n * })\n * ```\n *\n * @public\n */\nexport const arrowBindingProps: RecordProps<TLArrowBinding> = {\n\tterminal: T.literalEnum('start', 'end'),\n\tnormalizedAnchor: vecModelValidator,\n\tisExact: T.boolean,\n\tisPrecise: T.boolean,\n\tsnap: ElbowArrowSnap,\n}\n\n/**\n * Represents a binding relationship between an arrow shape and another shape.\n * Arrow bindings allow arrows to connect to and follow other shapes, maintaining\n * the connection even when shapes are moved or transformed.\n *\n * @example\n * ```ts\n * const arrowBinding: TLArrowBinding = {\n *   id: 'binding:abc123',\n *   typeName: 'binding',\n *   type: 'arrow',\n *   fromId: 'shape:arrow1', // The arrow shape\n *   toId: 'shape:rectangle1', // The target shape\n *   props: {\n *     terminal: 'end',\n *     normalizedAnchor: { x: 0.5, y: 0.5 },\n *     isExact: false,\n *     isPrecise: true,\n *     snap: 'edge'\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLArrowBinding = TLBaseBinding<'arrow', TLArrowBindingProps>\n\n/**\n * Version identifiers for arrow binding property migrations.\n * Each version represents a schema change that requires data migration.\n *\n * @example\n * ```ts\n * // Check if migration is needed\n * if (bindingVersion < arrowBindingVersions.AddSnap) {\n *   // Apply AddSnap migration\n * }\n * ```\n *\n * @public\n */\nexport const arrowBindingVersions = createBindingPropsMigrationIds('arrow', {\n\tAddSnap: 1,\n})\n\n/**\n * Migration sequence for arrow binding properties.\n * Handles schema evolution over time by defining how to migrate data between versions.\n *\n * The sequence includes:\n * - **AddSnap (v1)**: Adds the `snap` property with default value 'none'\n *\n * @example\n * ```ts\n * import { arrowBindingMigrations } from '@tldraw/tlschema'\n *\n * // Apply migrations when loading older data\n * const migratedBinding = arrowBindingMigrations.migrate(oldBinding)\n * ```\n *\n * @public\n */\nexport const arrowBindingMigrations = createBindingPropsMigrationSequence({\n\tsequence: [\n\t\t{ dependsOn: [arrowShapeVersions.ExtractBindings] },\n\t\t{\n\t\t\tid: arrowBindingVersions.AddSnap,\n\t\t\tup: (props) => {\n\t\t\t\tprops.snap = 'none'\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.snap\n\t\t\t},\n\t\t},\n\t],\n})\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAkB;AAClB,4BAA4C;AAC5C,uBAGO;AAEP,0BAAmC;AAoB5B,MAAM,iBAAiB,kBAAE,YAAY,UAAU,cAAc,QAAQ,MAAM;AAyE3E,MAAM,oBAAiD;AAAA,EAC7D,UAAU,kBAAE,YAAY,SAAS,KAAK;AAAA,EACtC,kBAAkB;AAAA,EAClB,SAAS,kBAAE;AAAA,EACX,WAAW,kBAAE;AAAA,EACb,MAAM;AACP;AA4CO,MAAM,2BAAuB,iDAA+B,SAAS;AAAA,EAC3E,SAAS;AACV,CAAC;AAmBM,MAAM,6BAAyB,sDAAoC;AAAA,EACzE,UAAU;AAAA,IACT,EAAE,WAAW,CAAC,uCAAmB,eAAe,EAAE;AAAA,IAClD;AAAA,MACC,IAAI,qBAAqB;AAAA,MACzB,IAAI,CAAC,UAAU;AACd,cAAM,OAAO;AAAA,MACd;AAAA,MACA,MAAM,CAAC,UAAU;AAChB,eAAO,MAAM;AAAA,MACd;AAAA,IACD;AAAA,EACD;AACD,CAAC;",
  "names": []
}
