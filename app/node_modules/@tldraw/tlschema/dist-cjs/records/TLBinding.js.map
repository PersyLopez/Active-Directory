{
  "version": 3,
  "sources": ["../../src/records/TLBinding.ts"],
  "sourcesContent": ["import {\n\tRecordId,\n\tUnknownRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n} from '@tldraw/store'\nimport { Expand, mapObjectMapValues, uniqueId } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { TLArrowBinding } from '../bindings/TLArrowBinding'\nimport { TLBaseBinding, createBindingValidator } from '../bindings/TLBaseBinding'\nimport { SchemaPropsInfo } from '../createTLSchema'\nimport { TLPropsMigrations } from '../recordsWithProps'\n\n/**\n * The default set of bindings that are available in the editor.\n * Currently includes only arrow bindings, but can be extended with custom bindings.\n *\n * @example\n * ```ts\n * // Arrow binding connects an arrow to shapes\n * const arrowBinding: TLDefaultBinding = {\n *   id: 'binding:arrow1',\n *   typeName: 'binding',\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   props: {\n *     terminal: 'end',\n *     normalizedAnchor: { x: 0.5, y: 0.5 },\n *     isExact: false,\n *     isPrecise: true\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultBinding = TLArrowBinding\n\n/**\n * A type for a binding that is available in the editor but whose type is\n * unknown\u2014either one of the editor's default bindings or else a custom binding.\n * Used internally for type-safe handling of bindings with unknown structure.\n *\n * @example\n * ```ts\n * // Function that works with any binding type\n * function processBinding(binding: TLUnknownBinding) {\n *   console.log(`Processing ${binding.type} binding from ${binding.fromId} to ${binding.toId}`)\n *   // Handle binding properties generically\n * }\n * ```\n *\n * @public\n */\nexport type TLUnknownBinding = TLBaseBinding<string, object>\n\n/**\n * The set of all bindings that are available in the editor, including unknown bindings.\n * Bindings represent relationships between shapes, such as arrows connecting to other shapes.\n *\n * @example\n * ```ts\n * // Check binding type and handle accordingly\n * function handleBinding(binding: TLBinding) {\n *   switch (binding.type) {\n *     case 'arrow':\n *       // Handle arrow binding\n *       break\n *     default:\n *       // Handle unknown custom binding\n *       break\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLBinding = TLDefaultBinding | TLUnknownBinding\n\n/**\n * Type for updating existing bindings with partial properties.\n * Only the id and type are required, all other properties are optional.\n *\n * @example\n * ```ts\n * // Update arrow binding properties\n * const bindingUpdate: TLBindingUpdate<TLArrowBinding> = {\n *   id: 'binding:arrow1',\n *   type: 'arrow',\n *   props: {\n *     normalizedAnchor: { x: 0.7, y: 0.3 } // Only update anchor position\n *   }\n * }\n *\n * editor.updateBindings([bindingUpdate])\n * ```\n *\n * @public\n */\nexport type TLBindingUpdate<T extends TLBinding = TLBinding> = Expand<{\n\tid: TLBindingId\n\ttype: T['type']\n\ttypeName?: T['typeName']\n\tfromId?: T['fromId']\n\ttoId?: T['toId']\n\tprops?: Partial<T['props']>\n\tmeta?: Partial<T['meta']>\n}>\n\n/**\n * Type for creating new bindings with required fromId and toId.\n * The id is optional and will be generated if not provided.\n *\n * @example\n * ```ts\n * // Create a new arrow binding\n * const newBinding: TLBindingCreate<TLArrowBinding> = {\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   props: {\n *     terminal: 'end',\n *     normalizedAnchor: { x: 0.5, y: 0.5 },\n *     isExact: false,\n *     isPrecise: true\n *   }\n * }\n *\n * editor.createBindings([newBinding])\n * ```\n *\n * @public\n */\nexport type TLBindingCreate<T extends TLBinding = TLBinding> = Expand<{\n\tid?: TLBindingId\n\ttype: T['type']\n\ttypeName?: T['typeName']\n\tfromId: T['fromId']\n\ttoId: T['toId']\n\tprops?: Partial<T['props']>\n\tmeta?: Partial<T['meta']>\n}>\n\n/**\n * Branded string type for binding record identifiers.\n * Prevents mixing binding IDs with other types of record IDs at compile time.\n *\n * @example\n * ```ts\n * import { createBindingId } from '@tldraw/tlschema'\n *\n * // Create a new binding ID\n * const bindingId: TLBindingId = createBindingId()\n *\n * // Use in binding records\n * const binding: TLBinding = {\n *   id: bindingId,\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   // ... other properties\n * }\n * ```\n *\n * @public\n */\nexport type TLBindingId = RecordId<TLUnknownBinding>\n\n/**\n * Migration version identifiers for the root binding record schema.\n * Currently empty as no migrations have been applied to the base binding structure.\n *\n * @example\n * ```ts\n * // Future migrations would be defined here\n * const rootBindingVersions = createMigrationIds('com.tldraw.binding', {\n *   AddNewProperty: 1,\n * } as const)\n * ```\n *\n * @public\n */\nexport const rootBindingVersions = createMigrationIds('com.tldraw.binding', {} as const)\n\n/**\n * Migration sequence for the root binding record structure.\n * Currently empty as the binding schema has not required any migrations yet.\n *\n * @example\n * ```ts\n * // Migrations would be automatically applied when loading old documents\n * const migratedStore = migrator.migrateStoreSnapshot({\n *   schema: oldSchema,\n *   store: oldStoreSnapshot\n * })\n * ```\n *\n * @public\n */\nexport const rootBindingMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.binding',\n\trecordType: 'binding',\n\tsequence: [],\n})\n\n/**\n * Type guard to check if a record is a TLBinding.\n * Useful for filtering or type narrowing when working with mixed record types.\n *\n * @param record - The record to check\n * @returns True if the record is a binding, false otherwise\n *\n * @example\n * ```ts\n * // Filter bindings from mixed records\n * const allRecords = store.allRecords()\n * const bindings = allRecords.filter(isBinding)\n *\n * // Type guard usage\n * function processRecord(record: UnknownRecord) {\n *   if (isBinding(record)) {\n *     // record is now typed as TLBinding\n *     console.log(`Binding from ${record.fromId} to ${record.toId}`)\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function isBinding(record?: UnknownRecord): record is TLBinding {\n\tif (!record) return false\n\treturn record.typeName === 'binding'\n}\n\n/**\n * Type guard to check if a string is a valid TLBindingId.\n * Validates that the ID follows the correct format for binding identifiers.\n *\n * @param id - The string to check\n * @returns True if the string is a valid binding ID, false otherwise\n *\n * @example\n * ```ts\n * // Validate binding IDs\n * const maybeBindingId = 'binding:abc123'\n * if (isBindingId(maybeBindingId)) {\n *   // maybeBindingId is now typed as TLBindingId\n *   const binding = store.get(maybeBindingId)\n * }\n *\n * // Filter binding IDs from mixed ID array\n * const mixedIds = ['shape:1', 'binding:2', 'page:3']\n * const bindingIds = mixedIds.filter(isBindingId)\n * ```\n *\n * @public\n */\nexport function isBindingId(id?: string): id is TLBindingId {\n\tif (!id) return false\n\treturn id.startsWith('binding:')\n}\n\n/**\n * Creates a new TLBindingId with proper formatting.\n * Generates a unique ID if none is provided, or formats a provided ID correctly.\n *\n * @param id - Optional custom ID suffix. If not provided, a unique ID is generated\n * @returns A properly formatted binding ID\n *\n * @example\n * ```ts\n * // Create with auto-generated ID\n * const bindingId1 = createBindingId() // 'binding:abc123'\n *\n * // Create with custom ID\n * const bindingId2 = createBindingId('myCustomBinding') // 'binding:myCustomBinding'\n *\n * // Use in binding creation\n * const binding: TLBinding = {\n *   id: createBindingId(),\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   // ... other properties\n * }\n * ```\n *\n * @public\n */\nexport function createBindingId(id?: string): TLBindingId {\n\treturn `binding:${id ?? uniqueId()}` as TLBindingId\n}\n\n/**\n * Creates a migration sequence for binding properties.\n * This is a pass-through function that validates and returns the provided migrations.\n *\n * @param migrations - The migration sequence for binding properties\n * @returns The validated migration sequence\n *\n * @example\n * ```ts\n * // Define migrations for custom binding properties\n * const myBindingMigrations = createBindingPropsMigrationSequence({\n *   sequence: [\n *     {\n *       id: 'com.myapp.binding.custom/1.0.0',\n *       up: (props) => ({ ...props, newProperty: 'default' }),\n *       down: ({ newProperty, ...props }) => props\n *     }\n *   ]\n * })\n * ```\n *\n * @public\n */\nexport function createBindingPropsMigrationSequence(\n\tmigrations: TLPropsMigrations\n): TLPropsMigrations {\n\treturn migrations\n}\n\n/**\n * Creates properly formatted migration IDs for binding property migrations.\n * Follows the convention: 'com.tldraw.binding.\\{bindingType\\}/\\{version\\}'\n *\n * @param bindingType - The type of binding these migrations apply to\n * @param ids - Object mapping migration names to version numbers\n * @returns Object with formatted migration IDs\n *\n * @example\n * ```ts\n * // Create migration IDs for custom binding\n * const myBindingVersions = createBindingPropsMigrationIds('myCustomBinding', {\n *   AddNewProperty: 1,\n *   UpdateProperty: 2\n * })\n *\n * // Result:\n * // {\n * //   AddNewProperty: 'com.tldraw.binding.myCustomBinding/1',\n * //   UpdateProperty: 'com.tldraw.binding.myCustomBinding/2'\n * // }\n * ```\n *\n * @public\n */\nexport function createBindingPropsMigrationIds<S extends string, T extends Record<string, number>>(\n\tbindingType: S,\n\tids: T\n): { [k in keyof T]: `com.tldraw.binding.${S}/${T[k]}` } {\n\treturn mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`) as any\n}\n\n/**\n * Creates a record type for TLBinding with validation based on the provided binding schemas.\n * This function is used internally to configure the binding record type in the schema.\n *\n * @param bindings - Record mapping binding type names to their schema information\n * @returns A configured record type for bindings with validation\n *\n * @example\n * ```ts\n * // Used internally when creating schemas\n * const bindingRecordType = createBindingRecordType({\n *   arrow: {\n *     props: arrowBindingProps,\n *     meta: arrowBindingMeta\n *   }\n * })\n * ```\n *\n * @internal\n */\nexport function createBindingRecordType(bindings: Record<string, SchemaPropsInfo>) {\n\treturn createRecordType<TLBinding>('binding', {\n\t\tscope: 'document',\n\t\tvalidator: T.model(\n\t\t\t'binding',\n\t\t\tT.union(\n\t\t\t\t'type',\n\t\t\t\tmapObjectMapValues(bindings, (type, { props, meta }) =>\n\t\t\t\t\tcreateBindingValidator(type, props, meta)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t}).withDefaultProperties(() => ({\n\t\tmeta: {},\n\t}))\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAMO;AACP,mBAAqD;AACrD,sBAAkB;AAElB,2BAAsD;AA8K/C,MAAM,0BAAsB,iCAAmB,sBAAsB,CAAC,CAAU;AAiBhF,MAAM,4BAAwB,4CAA8B;AAAA,EAClE,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,UAAU,CAAC;AACZ,CAAC;AA0BM,SAAS,UAAU,QAA6C;AACtE,MAAI,CAAC,OAAQ,QAAO;AACpB,SAAO,OAAO,aAAa;AAC5B;AAyBO,SAAS,YAAY,IAAgC;AAC3D,MAAI,CAAC,GAAI,QAAO;AAChB,SAAO,GAAG,WAAW,UAAU;AAChC;AA6BO,SAAS,gBAAgB,IAA0B;AACzD,SAAO,WAAW,UAAM,uBAAS,CAAC;AACnC;AAyBO,SAAS,oCACf,YACoB;AACpB,SAAO;AACR;AA2BO,SAAS,+BACf,aACA,KACwD;AACxD,aAAO,iCAAmB,KAAK,CAAC,IAAI,MAAM,sBAAsB,WAAW,IAAI,CAAC,EAAE;AACnF;AAsBO,SAAS,wBAAwB,UAA2C;AAClF,aAAO,+BAA4B,WAAW;AAAA,IAC7C,OAAO;AAAA,IACP,WAAW,kBAAE;AAAA,MACZ;AAAA,MACA,kBAAE;AAAA,QACD;AAAA,YACA;AAAA,UAAmB;AAAA,UAAU,CAAC,MAAM,EAAE,OAAO,KAAK,UACjD,6CAAuB,MAAM,OAAO,IAAI;AAAA,QACzC;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAC,EAAE,sBAAsB,OAAO;AAAA,IAC/B,MAAM,CAAC;AAAA,EACR,EAAE;AACH;",
  "names": []
}
