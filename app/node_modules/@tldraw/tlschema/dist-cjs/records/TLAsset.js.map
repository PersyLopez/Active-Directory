{
  "version": 3,
  "sources": ["../../src/records/TLAsset.ts"],
  "sourcesContent": ["import {\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLBaseAsset } from '../assets/TLBaseAsset'\nimport { bookmarkAssetValidator, TLBookmarkAsset } from '../assets/TLBookmarkAsset'\nimport { imageAssetValidator, TLImageAsset } from '../assets/TLImageAsset'\nimport { TLVideoAsset, videoAssetValidator } from '../assets/TLVideoAsset'\nimport { TLShape } from './TLShape'\n\n/**\n * Union type representing all possible asset types in tldraw.\n * Assets represent external resources like images, videos, or bookmarks that can be referenced by shapes.\n *\n * @example\n * ```ts\n * const imageAsset: TLAsset = {\n *   id: 'asset:image123',\n *   typeName: 'asset',\n *   type: 'image',\n *   props: {\n *     src: 'https://example.com/image.jpg',\n *     w: 800,\n *     h: 600,\n *     mimeType: 'image/jpeg',\n *     isAnimated: false\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLAsset = TLImageAsset | TLVideoAsset | TLBookmarkAsset\n\n/**\n * Validator for TLAsset records that ensures runtime type safety.\n * Uses a discriminated union based on the 'type' field to validate different asset types.\n *\n * @example\n * ```ts\n * // Validation happens automatically when assets are stored\n * try {\n *   const validatedAsset = assetValidator.validate(assetData)\n *   store.put([validatedAsset])\n * } catch (error) {\n *   console.error('Asset validation failed:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const assetValidator: T.Validator<TLAsset> = T.model(\n\t'asset',\n\tT.union('type', {\n\t\timage: imageAssetValidator,\n\t\tvideo: videoAssetValidator,\n\t\tbookmark: bookmarkAssetValidator,\n\t})\n)\n\n/**\n * Migration version identifiers for asset record schema evolution.\n * Each version represents a breaking change that requires data migration.\n *\n * @example\n * ```ts\n * // Check if a migration is needed\n * const needsMigration = currentVersion < assetVersions.AddMeta\n * ```\n *\n * @public\n */\nexport const assetVersions = createMigrationIds('com.tldraw.asset', {\n\tAddMeta: 1,\n} as const)\n\n/**\n * Migration sequence for evolving asset record structure over time.\n * Handles converting asset records from older schema versions to current format.\n *\n * @example\n * ```ts\n * // Migration is applied automatically when loading old documents\n * const migratedStore = migrator.migrateStoreSnapshot({\n *   schema: oldSchema,\n *   store: oldStoreSnapshot\n * })\n * ```\n *\n * @public\n */\nexport const assetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset',\n\trecordType: 'asset',\n\tsequence: [\n\t\t{\n\t\t\tid: assetVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * Partial type for TLAsset allowing optional properties except id and type.\n * Useful for creating or updating assets where not all properties need to be specified.\n *\n * @example\n * ```ts\n * // Create a partial asset for updating\n * const partialAsset: TLAssetPartial<TLImageAsset> = {\n *   id: 'asset:image123',\n *   type: 'image',\n *   props: {\n *     w: 800 // Only updating width\n *   }\n * }\n *\n * // Use in asset updates\n * editor.updateAssets([partialAsset])\n * ```\n *\n * @public\n */\nexport type TLAssetPartial<T extends TLAsset = TLAsset> = T extends T\n\t? {\n\t\t\tid: TLAssetId\n\t\t\ttype: T['type']\n\t\t\tprops?: Partial<T['props']>\n\t\t\tmeta?: Partial<T['meta']>\n\t\t} & Partial<Omit<T, 'type' | 'id' | 'props' | 'meta'>>\n\t: never\n\n/**\n * Record type definition for TLAsset with validation and default properties.\n * Configures assets as document-scoped records that persist across sessions.\n *\n * @example\n * ```ts\n * // Create a new asset record\n * const assetRecord = AssetRecordType.create({\n *   id: 'asset:image123',\n *   type: 'image',\n *   props: {\n *     src: 'https://example.com/image.jpg',\n *     w: 800,\n *     h: 600,\n *     mimeType: 'image/jpeg',\n *     isAnimated: false\n *   }\n * })\n *\n * // Store the asset\n * store.put([assetRecord])\n * ```\n *\n * @public\n */\nexport const AssetRecordType = createRecordType<TLAsset>('asset', {\n\tvalidator: assetValidator,\n\tscope: 'document',\n}).withDefaultProperties(() => ({\n\tmeta: {},\n}))\n\n/**\n * Branded string type for asset record identifiers.\n * Prevents mixing asset IDs with other types of record IDs at compile time.\n *\n * @example\n * ```ts\n * import { createAssetId } from '@tldraw/tlschema'\n *\n * // Create a new asset ID\n * const assetId: TLAssetId = createAssetId()\n *\n * // Use in asset records\n * const asset: TLAsset = {\n *   id: assetId,\n *   // ... other properties\n * }\n *\n * // Reference in shapes\n * const imageShape: TLImageShape = {\n *   props: {\n *     assetId: assetId,\n *     // ... other properties\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLAssetId = RecordId<TLBaseAsset<any, any>>\n\n/**\n * Union type of all shapes that reference assets through an assetId property.\n * Includes image shapes, video shapes, and any other shapes that depend on external assets.\n *\n * @example\n * ```ts\n * // Function that works with any asset-based shape\n * function handleAssetShape(shape: TLAssetShape) {\n *   const assetId = shape.props.assetId\n *   if (assetId) {\n *     const asset = editor.getAsset(assetId)\n *     // Handle the asset...\n *   }\n * }\n *\n * // Use with image or video shapes\n * const imageShape: TLImageShape = { props: { assetId: 'asset:img1' } }\n * const videoShape: TLVideoShape = { props: { assetId: 'asset:vid1' } }\n * handleAssetShape(imageShape) // Works\n * handleAssetShape(videoShape) // Works\n * ```\n *\n * @public\n */\nexport type TLAssetShape = Extract<TLShape, { props: { assetId: TLAssetId } }>\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAKO;AACP,sBAAkB;AAElB,6BAAwD;AACxD,0BAAkD;AAClD,0BAAkD;AA6C3C,MAAM,iBAAuC,kBAAE;AAAA,EACrD;AAAA,EACA,kBAAE,MAAM,QAAQ;AAAA,IACf,OAAO;AAAA,IACP,OAAO;AAAA,IACP,UAAU;AAAA,EACX,CAAC;AACF;AAcO,MAAM,oBAAgB,iCAAmB,oBAAoB;AAAA,EACnE,SAAS;AACV,CAAU;AAiBH,MAAM,sBAAkB,4CAA8B;AAAA,EAC5D,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,UAAU;AAAA,IACT;AAAA,MACC,IAAI,cAAc;AAAA,MAClB,IAAI,CAAC,WAAW;AACf;AAAC,QAAC,OAAe,OAAO,CAAC;AAAA,MAC1B;AAAA,IACD;AAAA,EACD;AACD,CAAC;AAyDM,MAAM,sBAAkB,+BAA0B,SAAS;AAAA,EACjE,WAAW;AAAA,EACX,OAAO;AACR,CAAC,EAAE,sBAAsB,OAAO;AAAA,EAC/B,MAAM,CAAC;AACR,EAAE;",
  "names": []
}
