{
  "version": 3,
  "sources": ["../../src/records/TLShape.ts"],
  "sourcesContent": ["import {\n\tRecordId,\n\tUnknownRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n} from '@tldraw/store'\nimport { mapObjectMapValues, uniqueId } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { SchemaPropsInfo } from '../createTLSchema'\nimport { TLPropsMigrations } from '../recordsWithProps'\nimport { TLArrowShape } from '../shapes/TLArrowShape'\nimport { TLBaseShape, createShapeValidator } from '../shapes/TLBaseShape'\nimport { TLBookmarkShape } from '../shapes/TLBookmarkShape'\nimport { TLDrawShape } from '../shapes/TLDrawShape'\nimport { TLEmbedShape } from '../shapes/TLEmbedShape'\nimport { TLFrameShape } from '../shapes/TLFrameShape'\nimport { TLGeoShape } from '../shapes/TLGeoShape'\nimport { TLGroupShape } from '../shapes/TLGroupShape'\nimport { TLHighlightShape } from '../shapes/TLHighlightShape'\nimport { TLImageShape } from '../shapes/TLImageShape'\nimport { TLLineShape } from '../shapes/TLLineShape'\nimport { TLNoteShape } from '../shapes/TLNoteShape'\nimport { TLTextShape } from '../shapes/TLTextShape'\nimport { TLVideoShape } from '../shapes/TLVideoShape'\nimport { StyleProp } from '../styles/StyleProp'\nimport { TLPageId } from './TLPage'\n\n/**\n * The default set of shapes that are available in the editor.\n *\n * This union type represents all the built-in shape types supported by tldraw,\n * including arrows, bookmarks, drawings, embeds, frames, geometry shapes,\n * groups, images, lines, notes, text, videos, and highlights.\n *\n * @example\n * ```ts\n * // Check if a shape is a default shape type\n * function isDefaultShape(shape: TLShape): shape is TLDefaultShape {\n *   const defaultTypes = ['arrow', 'bookmark', 'draw', 'embed', 'frame', 'geo', 'group', 'image', 'line', 'note', 'text', 'video', 'highlight']\n *   return defaultTypes.includes(shape.type)\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultShape =\n\t| TLArrowShape\n\t| TLBookmarkShape\n\t| TLDrawShape\n\t| TLEmbedShape\n\t| TLFrameShape\n\t| TLGeoShape\n\t| TLGroupShape\n\t| TLImageShape\n\t| TLLineShape\n\t| TLNoteShape\n\t| TLTextShape\n\t| TLVideoShape\n\t| TLHighlightShape\n\n/**\n * A type for a shape that is available in the editor but whose type is\n * unknown\u2014either one of the editor's default shapes or else a custom shape.\n *\n * This is useful when working with shapes generically without knowing their specific type.\n * The shape type is a string and props are a generic object.\n *\n * @example\n * ```ts\n * // Handle any shape regardless of its specific type\n * function processUnknownShape(shape: TLUnknownShape) {\n *   console.log(`Processing shape of type: ${shape.type}`)\n *   console.log(`Position: (${shape.x}, ${shape.y})`)\n * }\n * ```\n *\n * @public\n */\nexport type TLUnknownShape = TLBaseShape<string, object>\n\n/**\n * The set of all shapes that are available in the editor, including unknown shapes.\n *\n * This is the primary shape type used throughout tldraw. It includes both the\n * built-in default shapes and any custom shapes that might be added.\n *\n * @example\n * ```ts\n * // Work with any shape in the editor\n * function moveShape(shape: TLShape, deltaX: number, deltaY: number): TLShape {\n *   return {\n *     ...shape,\n *     x: shape.x + deltaX,\n *     y: shape.y + deltaY\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLShape = TLDefaultShape | TLUnknownShape\n\n/**\n * A partial version of a shape, useful for updates and patches.\n *\n * This type represents a shape where all properties except `id` and `type` are optional.\n * It's commonly used when updating existing shapes or creating shape patches.\n *\n * @example\n * ```ts\n * // Update a shape's position\n * const shapeUpdate: TLShapePartial = {\n *   id: 'shape:123',\n *   type: 'geo',\n *   x: 100,\n *   y: 200\n * }\n *\n * // Update shape properties\n * const propsUpdate: TLShapePartial<TLGeoShape> = {\n *   id: 'shape:123',\n *   type: 'geo',\n *   props: {\n *     w: 150,\n *     h: 100\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLShapePartial<T extends TLShape = TLShape> = T extends T\n\t? {\n\t\t\tid: TLShapeId\n\t\t\ttype: T['type']\n\t\t\tprops?: Partial<T['props']>\n\t\t\tmeta?: Partial<T['meta']>\n\t\t} & Partial<Omit<T, 'type' | 'id' | 'props' | 'meta'>>\n\t: never\n\n/**\n * A unique identifier for a shape record.\n *\n * Shape IDs are branded strings that start with \"shape:\" followed by a unique identifier.\n * This type-safe approach prevents mixing up different types of record IDs.\n *\n * @example\n * ```ts\n * const shapeId: TLShapeId = createShapeId() // \"shape:abc123\"\n * const customId: TLShapeId = createShapeId('my-custom-id') // \"shape:my-custom-id\"\n * ```\n *\n * @public\n */\nexport type TLShapeId = RecordId<TLUnknownShape>\n\n/**\n * The ID of a shape's parent, which can be either a page or another shape.\n *\n * Shapes can be parented to pages (for top-level shapes) or to other shapes\n * (for shapes inside frames or groups).\n *\n * @example\n * ```ts\n * // Shape parented to a page\n * const pageParentId: TLParentId = 'page:main'\n *\n * // Shape parented to another shape (e.g., inside a frame)\n * const shapeParentId: TLParentId = 'shape:frame123'\n * ```\n *\n * @public\n */\nexport type TLParentId = TLPageId | TLShapeId\n\n/**\n * Migration version IDs for the root shape schema.\n *\n * These track the evolution of the base shape structure over time, ensuring\n * that shapes created in older versions can be migrated to newer formats.\n *\n * @example\n * ```ts\n * // Check if a migration needs to be applied\n * if (shapeVersion < rootShapeVersions.AddIsLocked) {\n *   // Apply isLocked migration\n * }\n * ```\n *\n * @public\n */\nexport const rootShapeVersions = createMigrationIds('com.tldraw.shape', {\n\tAddIsLocked: 1,\n\tHoistOpacity: 2,\n\tAddMeta: 3,\n\tAddWhite: 4,\n} as const)\n\n/**\n * Migration sequence for the root shape record type.\n *\n * This sequence defines how shape records should be transformed when migrating\n * between different schema versions. Each migration handles a specific version\n * upgrade, ensuring data compatibility across tldraw versions.\n *\n * @public\n */\nexport const rootShapeMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.shape',\n\trecordType: 'shape',\n\tsequence: [\n\t\t{\n\t\t\tid: rootShapeVersions.AddIsLocked,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.isLocked = false\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tdelete record.isLocked\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.HoistOpacity,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.opacity = Number(record.props.opacity ?? '1')\n\t\t\t\tdelete record.props.opacity\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tconst opacity = record.opacity\n\t\t\t\tdelete record.opacity\n\t\t\t\trecord.props.opacity =\n\t\t\t\t\topacity < 0.175\n\t\t\t\t\t\t? '0.1'\n\t\t\t\t\t\t: opacity < 0.375\n\t\t\t\t\t\t\t? '0.25'\n\t\t\t\t\t\t\t: opacity < 0.625\n\t\t\t\t\t\t\t\t? '0.5'\n\t\t\t\t\t\t\t\t: opacity < 0.875\n\t\t\t\t\t\t\t\t\t? '0.75'\n\t\t\t\t\t\t\t\t\t: '1'\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.AddWhite,\n\t\t\tup: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tif (record.props.color === 'white') {\n\t\t\t\t\trecord.props.color = 'black'\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * Type guard to check if a record is a shape.\n *\n * @param record - The record to check\n * @returns True if the record is a shape, false otherwise\n *\n * @example\n * ```ts\n * const record = store.get('shape:abc123')\n * if (isShape(record)) {\n *   console.log(`Shape type: ${record.type}`)\n *   console.log(`Position: (${record.x}, ${record.y})`)\n * }\n * ```\n *\n * @public\n */\nexport function isShape(record?: UnknownRecord): record is TLShape {\n\tif (!record) return false\n\treturn record.typeName === 'shape'\n}\n\n/**\n * Type guard to check if a string is a valid shape ID.\n *\n * @param id - The string to check\n * @returns True if the string is a valid shape ID, false otherwise\n *\n * @example\n * ```ts\n * const id = 'shape:abc123'\n * if (isShapeId(id)) {\n *   const shape = store.get(id) // TypeScript knows id is TLShapeId\n * }\n *\n * // Check user input\n * function selectShape(id: string) {\n *   if (isShapeId(id)) {\n *     editor.selectShape(id)\n *   } else {\n *     console.error('Invalid shape ID format')\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function isShapeId(id?: string): id is TLShapeId {\n\tif (!id) return false\n\treturn id.startsWith('shape:')\n}\n\n/**\n * Creates a new shape ID.\n *\n * @param id - Optional custom ID suffix. If not provided, a unique ID will be generated\n * @returns A new shape ID with the \"shape:\" prefix\n *\n * @example\n * ```ts\n * // Create a shape with auto-generated ID\n * const shapeId = createShapeId() // \"shape:abc123\"\n *\n * // Create a shape with custom ID\n * const customShapeId = createShapeId('my-rectangle') // \"shape:my-rectangle\"\n *\n * // Use in shape creation\n * const newShape: TLGeoShape = {\n *   id: createShapeId(),\n *   type: 'geo',\n *   x: 100,\n *   y: 200,\n *   // ... other properties\n * }\n * ```\n *\n * @public\n */\nexport function createShapeId(id?: string): TLShapeId {\n\treturn `shape:${id ?? uniqueId()}` as TLShapeId\n}\n\n/**\n * Extracts style properties from a shape's props definition and maps them to their property keys.\n *\n * This function analyzes shape property validators to identify which ones are style properties\n * and creates a mapping from StyleProp instances to their corresponding property keys.\n * It also validates that each style property is only used once per shape.\n *\n * @param props - Record of property validators for a shape type\n * @returns Map from StyleProp instances to their property keys\n * @throws Error if a style property is used more than once in the same shape\n *\n * @example\n * ```ts\n * const geoShapeProps = {\n *   color: DefaultColorStyle,\n *   fill: DefaultFillStyle,\n *   width: T.number,\n *   height: T.number\n * }\n *\n * const styleMap = getShapePropKeysByStyle(geoShapeProps)\n * // styleMap.get(DefaultColorStyle) === 'color'\n * // styleMap.get(DefaultFillStyle) === 'fill'\n * ```\n *\n * @internal\n */\nexport function getShapePropKeysByStyle(props: Record<string, T.Validatable<any>>) {\n\tconst propKeysByStyle = new Map<StyleProp<unknown>, string>()\n\tfor (const [key, prop] of Object.entries(props)) {\n\t\tif (prop instanceof StyleProp) {\n\t\t\tif (propKeysByStyle.has(prop)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`\n\t\t\t\t)\n\t\t\t}\n\t\t\tpropKeysByStyle.set(prop, key)\n\t\t}\n\t}\n\treturn propKeysByStyle\n}\n\n/**\n * Creates a migration sequence for shape properties.\n *\n * This is a pass-through function that maintains the same structure as the input.\n * It's used for consistency and to provide a clear API for defining shape property migrations.\n *\n * @param migrations - The migration sequence to create\n * @returns The same migration sequence (pass-through)\n *\n * @example\n * ```ts\n * const myShapeMigrations = createShapePropsMigrationSequence({\n *   sequence: [\n *     {\n *       id: 'com.myapp.shape.custom/1.0.0',\n *       up: (props) => ({ ...props, newProperty: 'default' }),\n *       down: ({ newProperty, ...props }) => props\n *     }\n *   ]\n * })\n * ```\n *\n * @public\n */\nexport function createShapePropsMigrationSequence(\n\tmigrations: TLPropsMigrations\n): TLPropsMigrations {\n\treturn migrations\n}\n\n/**\n * Creates properly formatted migration IDs for shape properties.\n *\n * Generates standardized migration IDs following the convention:\n * `com.tldraw.shape.{shapeType}/{version}`\n *\n * @param shapeType - The type of shape these migrations apply to\n * @param ids - Record mapping migration names to version numbers\n * @returns Record with the same keys but formatted migration ID values\n *\n * @example\n * ```ts\n * const myShapeVersions = createShapePropsMigrationIds('custom', {\n *   AddColor: 1,\n *   AddSize: 2,\n *   RefactorProps: 3\n * })\n * // Result: {\n * //   AddColor: 'com.tldraw.shape.custom/1',\n * //   AddSize: 'com.tldraw.shape.custom/2',\n * //   RefactorProps: 'com.tldraw.shape.custom/3'\n * // }\n * ```\n *\n * @public\n */\nexport function createShapePropsMigrationIds<\n\tconst S extends string,\n\tconst T extends Record<string, number>,\n>(shapeType: S, ids: T): { [k in keyof T]: `com.tldraw.shape.${S}/${T[k]}` } {\n\treturn mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`) as any\n}\n\n/**\n * Creates the record type definition for shapes.\n *\n * This function generates a complete record type for shapes that includes validation\n * for all registered shape types. It combines the base shape properties with\n * type-specific properties and creates a union validator that can handle any\n * registered shape type.\n *\n * @param shapes - Record of shape type names to their schema configuration\n * @returns A complete RecordType for shapes with proper validation and default properties\n *\n * @example\n * ```ts\n * const shapeRecordType = createShapeRecordType({\n *   geo: { props: geoShapeProps, migrations: geoMigrations },\n *   arrow: { props: arrowShapeProps, migrations: arrowMigrations }\n * })\n * ```\n *\n * @internal\n */\nexport function createShapeRecordType(shapes: Record<string, SchemaPropsInfo>) {\n\treturn createRecordType<TLShape>('shape', {\n\t\tscope: 'document',\n\t\tvalidator: T.model(\n\t\t\t'shape',\n\t\t\tT.union(\n\t\t\t\t'type',\n\t\t\t\tmapObjectMapValues(shapes, (type, { props, meta }) =>\n\t\t\t\t\tcreateShapeValidator(type, props, meta)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t}).withDefaultProperties(() => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\trotation: 0,\n\t\tisLocked: false,\n\t\topacity: 1,\n\t\tmeta: {},\n\t}))\n}\n"],
  "mappings": "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",
  "names": []
}
