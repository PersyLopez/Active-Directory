import { BaseRecord } from '@tldraw/store';
import { Expand } from '@tldraw/utils';
import { IndexKey } from '@tldraw/utils';
import { JsonObject } from '@tldraw/utils';
import { LegacyMigrations } from '@tldraw/store';
import { MakeUndefinedOptional } from '@tldraw/utils';
import { MigrationId } from '@tldraw/store';
import { MigrationSequence } from '@tldraw/store';
import { RecordId } from '@tldraw/store';
import { RecordType } from '@tldraw/store';
import { SerializedStore } from '@tldraw/store';
import { Signal } from '@tldraw/state';
import { StandaloneDependsOn } from '@tldraw/store';
import { Store } from '@tldraw/store';
import { StoreSchema } from '@tldraw/store';
import { StoreSnapshot } from '@tldraw/store';
import { StoreValidator } from '@tldraw/store';
import { T } from '@tldraw/validate';
import { UnknownRecord } from '@tldraw/store';

/**
 * Migration sequence for arrow binding properties.
 * Handles schema evolution over time by defining how to migrate data between versions.
 *
 * The sequence includes:
 * - **AddSnap (v1)**: Adds the `snap` property with default value 'none'
 *
 * @example
 * ```ts
 * import { arrowBindingMigrations } from '@tldraw/tlschema'
 *
 * // Apply migrations when loading older data
 * const migratedBinding = arrowBindingMigrations.migrate(oldBinding)
 * ```
 *
 * @public
 */
export declare const arrowBindingMigrations: TLPropsMigrations;

/**
 * Validation schema for arrow binding properties.
 * Defines the runtime validation rules for each property in TLArrowBindingProps.
 *
 * @example
 * ```ts
 * import { arrowBindingProps } from '@tldraw/tlschema'
 *
 * // Use in custom shape schema
 * const customSchema = createTLSchema({
 *   bindings: {
 *     arrow: {
 *       props: arrowBindingProps,
 *       migrations: arrowBindingMigrations
 *     }
 *   }
 * })
 * ```
 *
 * @public
 */
export declare const arrowBindingProps: RecordProps<TLArrowBinding>;

/**
 * Version identifiers for arrow binding property migrations.
 * Each version represents a schema change that requires data migration.
 *
 * @example
 * ```ts
 * // Check if migration is needed
 * if (bindingVersion < arrowBindingVersions.AddSnap) {
 *   // Apply AddSnap migration
 * }
 * ```
 *
 * @public
 */
export declare const arrowBindingVersions: {
    AddSnap: `com.tldraw.binding.arrow/${number}`;
};

/**
 * Style property for the arrowhead at the end of an arrow.
 *
 * Defines the visual style of the arrowhead at the end of the arrow path.
 * Defaults to 'arrow' style, giving arrows their characteristic pointed appearance.
 *
 * @example
 * ```ts
 * // Arrow with different start and end arrowheads
 * const doubleArrow: TLArrowShape = {
 *   // ... other properties
 *   props: {
 *     arrowheadStart: 'triangle',
 *     arrowheadEnd: 'diamond',
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const ArrowShapeArrowheadEndStyle: EnumStyleProp<"arrow" | "bar" | "diamond" | "dot" | "inverted" | "none" | "pipe" | "square" | "triangle">;

/**
 * Style property for the arrowhead at the start of an arrow.
 *
 * Defines the visual style of the arrowhead at the beginning of the arrow path.
 * Can be one of several predefined styles or none for no arrowhead.
 *
 * @example
 * ```ts
 * // Arrow with no start arrowhead but triangle end arrowhead
 * const arrow: TLArrowShape = {
 *   // ... other properties
 *   props: {
 *     arrowheadStart: 'none',
 *     arrowheadEnd: 'triangle',
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const ArrowShapeArrowheadStartStyle: EnumStyleProp<"arrow" | "bar" | "diamond" | "dot" | "inverted" | "none" | "pipe" | "square" | "triangle">;

/**
 * Style property for arrow shape kind, determining how the arrow is drawn.
 *
 * Arrows can be drawn as arcs (curved) or elbows (angled with straight segments).
 * This affects the visual appearance and behavior of arrow shapes.
 *
 * @example
 * ```ts
 * // Create an arrow with arc style (curved)
 * const arcArrow: TLArrowShape = {
 *   // ... other properties
 *   props: {
 *     kind: 'arc',
 *     // ... other props
 *   }
 * }
 *
 * // Create an arrow with elbow style (angled)
 * const elbowArrow: TLArrowShape = {
 *   // ... other properties
 *   props: {
 *     kind: 'elbow',
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const ArrowShapeKindStyle: EnumStyleProp<"arc" | "elbow">;

/**
 * Complete migration sequence for arrow shapes.
 *
 * Defines all the migrations needed to transform arrow shape data from older
 * versions to the current version. Each migration handles a specific schema change,
 * ensuring backward compatibility and smooth data evolution.
 *
 * @public
 */
export declare const arrowShapeMigrations: MigrationSequence;

/**
 * Validation configuration for arrow shape properties.
 *
 * Defines the validators for each property of an arrow shape, ensuring that
 * arrow shape data is valid and conforms to the expected types and constraints.
 *
 * @example
 * ```ts
 * // The validators ensure proper typing and validation
 * const validator = T.object(arrowShapeProps)
 * const validArrowProps = validator.validate({
 *   kind: 'arc',
 *   start: { x: 0, y: 0 },
 *   end: { x: 100, y: 50 },
 *   // ... other required properties
 * })
 * ```
 *
 * @public
 */
export declare const arrowShapeProps: RecordProps<TLArrowShape>;

/**
 * Migration version identifiers for arrow shape properties.
 *
 * These track the evolution of the arrow shape schema over time, with each
 * version representing a specific change to the arrow shape structure or properties.
 *
 * @example
 * ```ts
 * // Used internally for migration system
 * if (version < arrowShapeVersions.AddLabelColor) {
 *   // Apply label color migration
 * }
 * ```
 *
 * @public
 */
export declare const arrowShapeVersions: {
    readonly AddElbow: "com.tldraw.shape.arrow/6";
    readonly AddIsPrecise: "com.tldraw.shape.arrow/2";
    readonly AddLabelColor: "com.tldraw.shape.arrow/1";
    readonly AddLabelPosition: "com.tldraw.shape.arrow/3";
    readonly AddRichText: "com.tldraw.shape.arrow/7";
    readonly AddScale: "com.tldraw.shape.arrow/5";
    readonly ExtractBindings: "com.tldraw.shape.arrow/4";
};

/**
 * A validator for asset record type IDs. This validator ensures that asset IDs
 * follow the correct format and type structure required by tldraw's asset system.
 * Asset IDs are prefixed with 'asset:' followed by a unique identifier.
 *
 * @example
 * ```ts
 * import { assetIdValidator } from '@tldraw/tlschema'
 *
 * // Valid asset ID
 * const validId = 'asset:abc123'
 * console.log(assetIdValidator.isValid(validId)) // true
 *
 * // Invalid asset ID
 * const invalidId = 'shape:abc123'
 * console.log(assetIdValidator.isValid(invalidId)) // false
 * ```
 *
 * @public
 */
export declare const assetIdValidator: T.Validator<TLAssetId>;

/**
 * Migration sequence for evolving asset record structure over time.
 * Handles converting asset records from older schema versions to current format.
 *
 * @example
 * ```ts
 * // Migration is applied automatically when loading old documents
 * const migratedStore = migrator.migrateStoreSnapshot({
 *   schema: oldSchema,
 *   store: oldStoreSnapshot
 * })
 * ```
 *
 * @public
 */
export declare const assetMigrations: MigrationSequence;

/**
 * Record type definition for TLAsset with validation and default properties.
 * Configures assets as document-scoped records that persist across sessions.
 *
 * @example
 * ```ts
 * // Create a new asset record
 * const assetRecord = AssetRecordType.create({
 *   id: 'asset:image123',
 *   type: 'image',
 *   props: {
 *     src: 'https://example.com/image.jpg',
 *     w: 800,
 *     h: 600,
 *     mimeType: 'image/jpeg',
 *     isAnimated: false
 *   }
 * })
 *
 * // Store the asset
 * store.put([assetRecord])
 * ```
 *
 * @public
 */
export declare const AssetRecordType: RecordType<TLAsset, "props" | "type">;

/**
 * Validator for TLAsset records that ensures runtime type safety.
 * Uses a discriminated union based on the 'type' field to validate different asset types.
 *
 * @example
 * ```ts
 * // Validation happens automatically when assets are stored
 * try {
 *   const validatedAsset = assetValidator.validate(assetData)
 *   store.put([validatedAsset])
 * } catch (error) {
 *   console.error('Asset validation failed:', error.message)
 * }
 * ```
 *
 * @public
 */
export declare const assetValidator: T.Validator<TLAsset>;

/**
 * Validator for binding IDs. Ensures that binding identifiers follow the correct
 * format and type constraints required by the tldraw schema system.
 *
 * Used internally by the schema validation system to verify binding IDs when
 * records are created or modified. All binding IDs must be prefixed with 'binding:'.
 *
 * @example
 * ```ts
 * import { bindingIdValidator } from '@tldraw/tlschema'
 *
 * // Validate a binding ID
 * const isValid = bindingIdValidator.isValid('binding:abc123') // true
 * const isInvalid = bindingIdValidator.isValid('shape:abc123') // false
 *
 * // Use in custom validation schema
 * const customBindingValidator = T.object({
 *   id: bindingIdValidator,
 *   // ... other properties
 * })
 * ```
 *
 * @public
 */
export declare const bindingIdValidator: T.Validator<TLBindingId>;

/**
 * Migration sequence for bookmark shape properties across different schema versions.
 * Handles backwards compatibility when bookmark shape structure changes.
 *
 * @public
 */
export declare const bookmarkShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for bookmark shape properties.
 *
 * @public
 * @example
 * ```ts
 * // Validates bookmark shape properties
 * const isValid = bookmarkShapeProps.url.isValid('https://example.com')
 * ```
 */
export declare const bookmarkShapeProps: RecordProps<TLBookmarkShape>;

/**
 * A serializable model for 2D boxes.
 *
 * @public */
export declare interface BoxModel {
    x: number;
    y: number;
    w: number;
    h: number;
}

/**
 * Validator for BoxModel objects that ensures they have numeric x, y coordinates
 * for position and w, h values for width and height. Used throughout the schema
 * to validate bounding box and rectangular area data structures.
 *
 * @public
 * @example
 * ```ts
 * const box = { x: 10, y: 20, w: 100, h: 50 }
 * const isValid = boxModelValidator.check(box) // true
 *
 * const invalidBox = { x: 10, y: 20, w: -5, h: 50 }
 * const isValidNegative = boxModelValidator.check(invalidBox) // true (validator allows negative values)
 * ```
 */
export declare const boxModelValidator: T.ObjectValidator<BoxModel>;

/**
 * Record type definition for TLCamera with validation and default properties.
 * Configures cameras as session-scoped records that don't persist across sessions.
 *
 * @example
 * ```ts
 * // Create a new camera record with defaults
 * const cameraRecord = CameraRecordType.create({
 *   id: 'camera:main'
 *   // x: 0, y: 0, z: 1, meta: {} are applied as defaults
 * })
 *
 * // Create with custom position and zoom
 * const customCamera = CameraRecordType.create({
 *   id: 'camera:user1',
 *   x: -100,
 *   y: -50,
 *   z: 1.5,
 *   meta: { userId: 'user123' }
 * })
 *
 * // Store the camera
 * store.put([cameraRecord])
 * ```
 *
 * @public
 */
export declare const CameraRecordType: RecordType<TLCamera, never>;

/**
 * A validator for canvas UI color types.
 *
 * This validator ensures that color values are one of the valid canvas UI
 * color types defined in {@link TL_CANVAS_UI_COLOR_TYPES}. It provides
 * runtime type checking for canvas UI color properties.
 *
 * @example
 * ```ts
 * import { canvasUiColorTypeValidator } from '@tldraw/tlschema'
 *
 * // Validate a color value
 * try {
 *   const validColor = canvasUiColorTypeValidator.validate('accent')
 *   console.log('Valid color:', validColor)
 * } catch (error) {
 *   console.error('Invalid color:', error.message)
 * }
 * ```
 *
 * @public
 */
export declare const canvasUiColorTypeValidator: T.Validator<"accent" | "black" | "laser" | "muted-1" | "selection-fill" | "selection-stroke" | "white">;

/**
 * Creates a validator for a specific asset record type. This factory function generates
 * a complete validator that validates the entire asset record structure including the
 * base properties (id, typeName, type, meta) and the type-specific props.
 *
 * @param type - The asset type identifier (e.g., 'image', 'video', 'bookmark')
 * @param props - The validator for the asset's type-specific properties
 * @returns A complete validator for the asset record type
 *
 * @example
 * ```ts
 * import { createAssetValidator, TLBaseAsset } from '@tldraw/tlschema'
 * import { T } from '@tldraw/validate'
 *
 * // Define a custom asset type
 * type TLCustomAsset = TLBaseAsset<'custom', {
 *   url: string
 *   title: string
 *   description?: string
 * }>
 *
 * // Create validator for the custom asset
 * const customAssetValidator = createAssetValidator('custom', T.object({
 *   url: T.string,
 *   title: T.string,
 *   description: T.string.optional()
 * }))
 *
 * // Use the validator
 * const assetData = {
 *   id: 'asset:custom123',
 *   typeName: 'asset' as const,
 *   type: 'custom' as const,
 *   props: {
 *     url: 'https://example.com',
 *     title: 'My Custom Asset'
 *   },
 *   meta: {}
 * }
 *
 * const validatedAsset = customAssetValidator.validate(assetData)
 * ```
 *
 * @public
 */
export declare function createAssetValidator<Type extends string, Props extends JsonObject>(type: Type, props: T.Validator<Props>): T.ObjectValidator<Expand<    { [P in "id" | "meta" | "typeName" | (undefined extends Props ? never : "props") | (undefined extends Type ? never : "type")]: {
id: TLAssetId;
meta: JsonObject;
props: Props;
type: Type;
typeName: "asset";
}[P]; } & { [P_1 in (undefined extends Props ? "props" : never) | (undefined extends Type ? "type" : never)]?: {
id: TLAssetId;
meta: JsonObject;
props: Props;
type: Type;
typeName: "asset";
}[P_1] | undefined; }>>;

/**
 * Creates a new TLBindingId with proper formatting.
 * Generates a unique ID if none is provided, or formats a provided ID correctly.
 *
 * @param id - Optional custom ID suffix. If not provided, a unique ID is generated
 * @returns A properly formatted binding ID
 *
 * @example
 * ```ts
 * // Create with auto-generated ID
 * const bindingId1 = createBindingId() // 'binding:abc123'
 *
 * // Create with custom ID
 * const bindingId2 = createBindingId('myCustomBinding') // 'binding:myCustomBinding'
 *
 * // Use in binding creation
 * const binding: TLBinding = {
 *   id: createBindingId(),
 *   type: 'arrow',
 *   fromId: 'shape:arrow1',
 *   toId: 'shape:rectangle1',
 *   // ... other properties
 * }
 * ```
 *
 * @public
 */
export declare function createBindingId(id?: string): TLBindingId;

/**
 * Creates properly formatted migration IDs for binding property migrations.
 * Follows the convention: 'com.tldraw.binding.\{bindingType\}/\{version\}'
 *
 * @param bindingType - The type of binding these migrations apply to
 * @param ids - Object mapping migration names to version numbers
 * @returns Object with formatted migration IDs
 *
 * @example
 * ```ts
 * // Create migration IDs for custom binding
 * const myBindingVersions = createBindingPropsMigrationIds('myCustomBinding', {
 *   AddNewProperty: 1,
 *   UpdateProperty: 2
 * })
 *
 * // Result:
 * // {
 * //   AddNewProperty: 'com.tldraw.binding.myCustomBinding/1',
 * //   UpdateProperty: 'com.tldraw.binding.myCustomBinding/2'
 * // }
 * ```
 *
 * @public
 */
export declare function createBindingPropsMigrationIds<S extends string, T extends Record<string, number>>(bindingType: S, ids: T): {
    [k in keyof T]: `com.tldraw.binding.${S}/${T[k]}`;
};

/**
 * Creates a migration sequence for binding properties.
 * This is a pass-through function that validates and returns the provided migrations.
 *
 * @param migrations - The migration sequence for binding properties
 * @returns The validated migration sequence
 *
 * @example
 * ```ts
 * // Define migrations for custom binding properties
 * const myBindingMigrations = createBindingPropsMigrationSequence({
 *   sequence: [
 *     {
 *       id: 'com.myapp.binding.custom/1.0.0',
 *       up: (props) => ({ ...props, newProperty: 'default' }),
 *       down: ({ newProperty, ...props }) => props
 *     }
 *   ]
 * })
 * ```
 *
 * @public
 */
export declare function createBindingPropsMigrationSequence(migrations: TLPropsMigrations): TLPropsMigrations;

/**
 * Creates a runtime validator for a specific binding type. This factory function
 * generates a complete validation schema for custom bindings that extends TLBaseBinding.
 *
 * The validator ensures all binding records conform to the expected structure with
 * proper type safety and runtime validation. It validates the base binding properties
 * (id, type, fromId, toId) along with custom props and meta fields.
 *
 * @param type - The string literal type identifier for this binding (e.g., 'arrow', 'custom')
 * @param props - Optional validation schema for binding-specific properties
 * @param meta - Optional validation schema for metadata fields
 *
 * @returns A validator object that can validate complete binding records
 *
 * @example
 * ```ts
 * import { createBindingValidator } from '@tldraw/tlschema'
 * import { T } from '@tldraw/validate'
 *
 * // Create validator for a custom binding type
 * const myBindingValidator = createBindingValidator(
 *   'myBinding',
 *   {
 *     strength: T.number,
 *     color: T.string,
 *     enabled: T.boolean
 *   },
 *   {
 *     createdAt: T.number,
 *     author: T.string
 *   }
 * )
 *
 * // Validate a binding instance
 * const bindingData = {
 *   id: 'binding:123',
 *   typeName: 'binding',
 *   type: 'myBinding',
 *   fromId: 'shape:abc',
 *   toId: 'shape:def',
 *   props: {
 *     strength: 0.8,
 *     color: 'red',
 *     enabled: true
 *   },
 *   meta: {
 *     createdAt: Date.now(),
 *     author: 'user123'
 *   }
 * }
 *
 * const isValid = myBindingValidator.isValid(bindingData) // true
 * ```
 *
 * @example
 * ```ts
 * // Simple binding without custom props or meta
 * const simpleBindingValidator = createBindingValidator('simple')
 *
 * // This will use JsonValue validation for props and meta
 * const binding = {
 *   id: 'binding:456',
 *   typeName: 'binding',
 *   type: 'simple',
 *   fromId: 'shape:start',
 *   toId: 'shape:end',
 *   props: {}, // Any JSON value allowed
 *   meta: {}   // Any JSON value allowed
 * }
 * ```
 *
 * @public
 */
export declare function createBindingValidator<Type extends string, Props extends JsonObject, Meta extends JsonObject>(type: Type, props?: {
    [K in keyof Props]: T.Validatable<Props[K]>;
}, meta?: {
    [K in keyof Meta]: T.Validatable<Meta[K]>;
}): T.ObjectValidator<Expand<    { [P in "fromId" | "id" | "meta" | "toId" | "typeName" | (undefined extends Props ? never : "props") | (undefined extends Type ? never : "type")]: TLBaseBinding<Type, Props>[P]; } & { [P_1 in (undefined extends Props ? "props" : never) | (undefined extends Type ? "type" : never)]?: TLBaseBinding<Type, Props>[P_1] | undefined; }>>;

/**
 * Creates a derivation that represents the current presence state of the current user.
 *
 * This function returns a derivation factory that, when given a store, creates a computed signal
 * containing the user's current presence state. The presence state includes information like cursor
 * position, selected shapes, camera position, and user metadata that gets synchronized in
 * multiplayer scenarios.
 *
 * @param $user - A reactive signal containing the user information
 * @param instanceId - Optional custom instance ID. If not provided, one will be generated based on the store ID
 * @returns A function that takes a store and returns a computed signal of the user's presence state
 *
 * @example
 * ```ts
 * import { createPresenceStateDerivation } from '@tldraw/tlschema'
 * import { atom } from '@tldraw/state'
 *
 * const userSignal = atom('user', { id: 'user-123', name: 'Alice', color: '#ff0000' })
 * const presenceDerivation = createPresenceStateDerivation(userSignal)
 *
 * // Use with a store to get reactive presence state
 * const presenceState = presenceDerivation(store)
 * console.log(presenceState.get()) // Current user presence or null
 * ```
 *
 * @public
 */
export declare function createPresenceStateDerivation($user: Signal<TLPresenceUserInfo>, instanceId?: TLInstancePresence['id']): (store: TLStore) => Signal<null | TLInstancePresence>;

/**
 * Creates a new shape ID.
 *
 * @param id - Optional custom ID suffix. If not provided, a unique ID will be generated
 * @returns A new shape ID with the "shape:" prefix
 *
 * @example
 * ```ts
 * // Create a shape with auto-generated ID
 * const shapeId = createShapeId() // "shape:abc123"
 *
 * // Create a shape with custom ID
 * const customShapeId = createShapeId('my-rectangle') // "shape:my-rectangle"
 *
 * // Use in shape creation
 * const newShape: TLGeoShape = {
 *   id: createShapeId(),
 *   type: 'geo',
 *   x: 100,
 *   y: 200,
 *   // ... other properties
 * }
 * ```
 *
 * @public
 */
export declare function createShapeId(id?: string): TLShapeId;

/**
 * Creates properly formatted migration IDs for shape properties.
 *
 * Generates standardized migration IDs following the convention:
 * `com.tldraw.shape.{shapeType}/{version}`
 *
 * @param shapeType - The type of shape these migrations apply to
 * @param ids - Record mapping migration names to version numbers
 * @returns Record with the same keys but formatted migration ID values
 *
 * @example
 * ```ts
 * const myShapeVersions = createShapePropsMigrationIds('custom', {
 *   AddColor: 1,
 *   AddSize: 2,
 *   RefactorProps: 3
 * })
 * // Result: {
 * //   AddColor: 'com.tldraw.shape.custom/1',
 * //   AddSize: 'com.tldraw.shape.custom/2',
 * //   RefactorProps: 'com.tldraw.shape.custom/3'
 * // }
 * ```
 *
 * @public
 */
export declare function createShapePropsMigrationIds<const S extends string, const T extends Record<string, number>>(shapeType: S, ids: T): {
    [k in keyof T]: `com.tldraw.shape.${S}/${T[k]}`;
};

/**
 * Creates a migration sequence for shape properties.
 *
 * This is a pass-through function that maintains the same structure as the input.
 * It's used for consistency and to provide a clear API for defining shape property migrations.
 *
 * @param migrations - The migration sequence to create
 * @returns The same migration sequence (pass-through)
 *
 * @example
 * ```ts
 * const myShapeMigrations = createShapePropsMigrationSequence({
 *   sequence: [
 *     {
 *       id: 'com.myapp.shape.custom/1.0.0',
 *       up: (props) => ({ ...props, newProperty: 'default' }),
 *       down: ({ newProperty, ...props }) => props
 *     }
 *   ]
 * })
 * ```
 *
 * @public
 */
export declare function createShapePropsMigrationSequence(migrations: TLPropsMigrations): TLPropsMigrations;

/**
 * Creates a validator for a specific shape type.
 *
 * This function generates a complete validator that can validate shape records
 * of the specified type, including both the base shape properties and any
 * custom properties and metadata specific to that shape type.
 *
 * @param type - The string literal type for this shape (e.g., 'geo', 'arrow')
 * @param props - Optional validator configuration for shape-specific properties
 * @param meta - Optional validator configuration for shape-specific metadata
 * @returns A validator that can validate complete shape records of the specified type
 *
 * @example
 * ```ts
 * // Create a validator for a custom shape type
 * const customShapeValidator = createShapeValidator('custom', {
 *   width: T.number,
 *   height: T.number,
 *   color: T.string
 * })
 *
 * // Use the validator to validate shape data
 * const shapeData = {
 *   id: 'shape:abc123',
 *   typeName: 'shape',
 *   type: 'custom',
 *   x: 100,
 *   y: 200,
 *   // ... other base properties
 *   props: {
 *     width: 150,
 *     height: 100,
 *     color: 'red'
 *   }
 * }
 *
 * const validatedShape = customShapeValidator.validate(shapeData)
 * ```
 *
 * @public
 */
export declare function createShapeValidator<Type extends string, Props extends JsonObject, Meta extends JsonObject>(type: Type, props?: {
    [K in keyof Props]: T.Validatable<Props[K]>;
}, meta?: {
    [K in keyof Meta]: T.Validatable<Meta[K]>;
}): T.ObjectValidator<Expand<    { [P in "id" | "index" | "isLocked" | "meta" | "opacity" | "parentId" | "rotation" | "typeName" | "x" | "y" | (undefined extends Props ? never : "props") | (undefined extends Type ? never : "type")]: TLBaseShape<Type, Props>[P]; } & { [P_1 in (undefined extends Props ? "props" : never) | (undefined extends Type ? "type" : never)]?: TLBaseShape<Type, Props>[P_1] | undefined; }>>;

/**
 * Creates a complete TLSchema for use with tldraw stores. This schema defines the structure,
 * validation, and migration sequences for all record types in a tldraw application.
 *
 * The schema includes all core record types (pages, cameras, instances, etc.) plus the
 * shape and binding types you specify. Style properties are automatically collected from
 * all shapes to ensure consistency across the application.
 *
 * @param options - Configuration options for the schema
 *   - shapes - Shape schema configurations. Defaults to defaultShapeSchemas if not provided
 *   - bindings - Binding schema configurations. Defaults to defaultBindingSchemas if not provided
 *   - migrations - Additional migration sequences to include in the schema
 * @returns A complete TLSchema ready for use with Store creation
 *
 * @public
 * @example
 * ```ts
 * import { createTLSchema, defaultShapeSchemas, defaultBindingSchemas } from '@tldraw/tlschema'
 * import { Store } from '@tldraw/store'
 *
 * // Create schema with all default shapes and bindings
 * const schema = createTLSchema()
 *
 * // Create schema with custom shapes added
 * const customSchema = createTLSchema({
 *   shapes: {
 *     ...defaultShapeSchemas,
 *     myCustomShape: {
 *       props: myCustomShapeProps,
 *       migrations: myCustomShapeMigrations,
 *     },
 *   },
 * })
 *
 * // Create schema with only specific shapes
 * const minimalSchema = createTLSchema({
 *   shapes: {
 *     geo: defaultShapeSchemas.geo,
 *     text: defaultShapeSchemas.text,
 *   },
 *   bindings: defaultBindingSchemas,
 * })
 *
 * // Use the schema with a store
 * const store = new Store({
 *   schema: customSchema,
 *   props: {
 *     defaultName: 'My Drawing',
 *   },
 * })
 * ```
 */
export declare function createTLSchema({ shapes, bindings, migrations, }?: {
    bindings?: Record<string, SchemaPropsInfo>;
    migrations?: readonly MigrationSequence[];
    shapes?: Record<string, SchemaPropsInfo>;
}): TLSchema;

/**
 * Default binding schema configurations for all built-in tldraw binding types.
 * Bindings represent relationships between shapes, such as arrows connected to shapes.
 *
 * Currently includes:
 * - arrow: Bindings that connect arrow shapes to other shapes at specific anchor points
 *
 * @public
 * @example
 * ```ts
 * import { createTLSchema, defaultBindingSchemas } from '@tldraw/tlschema'
 *
 * // Use default bindings
 * const schema = createTLSchema({
 *   bindings: defaultBindingSchemas,
 * })
 *
 * // Add custom binding alongside defaults
 * const customSchema = createTLSchema({
 *   bindings: {
 *     ...defaultBindingSchemas,
 *     myCustomBinding: {
 *       props: myCustomBindingProps,
 *       migrations: myCustomBindingMigrations,
 *     },
 *   },
 * })
 * ```
 */
export declare const defaultBindingSchemas: {
    arrow: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLArrowBinding>;
    };
};

/**
 * Array of default color names available in tldraw's color palette.
 * These colors form the basis for the default color style system and are available
 * in both light and dark theme variants.
 *
 * @example
 * ```ts
 * import { defaultColorNames } from '@tldraw/tlschema'
 *
 * // Create a color picker with all default colors
 * const colorOptions = defaultColorNames.map(color => ({
 *   name: color,
 *   value: color
 * }))
 * ```
 *
 * @public
 */
export declare const defaultColorNames: readonly ["black", "grey", "light-violet", "violet", "blue", "light-blue", "yellow", "orange", "green", "light-green", "light-red", "red", "white"];

/**
 * Default color style property used by tldraw shapes for their primary color.
 * This style prop allows shapes to use any of the default color names and
 * automatically saves the last used value for new shapes.
 *
 * @example
 * ```ts
 * import { DefaultColorStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyShapeProps {
 *   color: typeof DefaultColorStyle
 *   // other props...
 * }
 *
 * // Set color on a shape
 * const shape = {
 *   // ... other properties
 *   props: {
 *     color: 'red' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultColorStyle: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;

/**
 * Complete color palette containing both light and dark theme definitions.
 * This object provides the full color system used by tldraw's default themes,
 * including all color variants and theme-specific adjustments.
 *
 * @example
 * ```ts
 * import { DefaultColorThemePalette } from '@tldraw/tlschema'
 *
 * // Get the dark theme colors
 * const darkTheme = DefaultColorThemePalette.darkMode
 * const redColor = darkTheme.red.solid // '#e03131'
 *
 * // Access light theme colors
 * const lightTheme = DefaultColorThemePalette.lightMode
 * const blueColor = lightTheme.blue.fill // '#4465e9'
 * ```
 *
 * @public
 */
export declare const DefaultColorThemePalette: {
    darkMode: TLDefaultColorTheme;
    lightMode: TLDefaultColorTheme;
};

/**
 * Default dash style property used by tldraw shapes for line styling.
 * Controls how shape outlines and lines are rendered with different dash patterns.
 *
 * Available values:
 * - `draw` - Hand-drawn, sketchy line style
 * - `solid` - Continuous solid line
 * - `dashed` - Evenly spaced dashes
 * - `dotted` - Evenly spaced dots
 *
 * @example
 * ```ts
 * import { DefaultDashStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyShapeProps {
 *   dash: typeof DefaultDashStyle
 *   // other props...
 * }
 *
 * // Create a shape with dashed outline
 * const shape = {
 *   // ... other properties
 *   props: {
 *     dash: 'dashed' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultDashStyle: EnumStyleProp<"dashed" | "dotted" | "draw" | "solid">;

/**
 * Default fill style property used by tldraw shapes for interior styling.
 * Controls how the inside of shapes are filled or left empty.
 *
 * Available values:
 * - `none` - No fill, shape interior is transparent
 * - `semi` - Semi-transparent fill using the shape's color
 * - `solid` - Solid fill using the shape's color
 * - `pattern` - Crosshatch pattern fill using the shape's color
 * - `fill` - Alternative solid fill variant
 *
 * @example
 * ```ts
 * import { DefaultFillStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyShapeProps {
 *   fill: typeof DefaultFillStyle
 *   // other props...
 * }
 *
 * // Create a shape with solid fill
 * const shape = {
 *   // ... other properties
 *   props: {
 *     fill: 'solid' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultFillStyle: EnumStyleProp<"fill" | "none" | "pattern" | "semi" | "solid">;

/**
 * Mapping of font style names to their corresponding CSS font-family declarations.
 * These are the actual CSS font families used when rendering text with each font style.
 *
 * @example
 * ```ts
 * import { DefaultFontFamilies, TLDefaultFontStyle } from '@tldraw/tlschema'
 *
 * // Get CSS font family for a font style
 * const fontStyle: TLDefaultFontStyle = 'mono'
 * const cssFamily = DefaultFontFamilies[fontStyle] // "'tldraw_mono', monospace"
 *
 * // Apply to DOM element
 * element.style.fontFamily = DefaultFontFamilies.sans
 * ```
 *
 * @public
 */
export declare const DefaultFontFamilies: {
    draw: string;
    mono: string;
    sans: string;
    serif: string;
};

/**
 * Default font style property used by tldraw shapes for text styling.
 * Controls which typeface is used for text content within shapes.
 *
 * Available values:
 * - `draw` - Hand-drawn, sketchy font style
 * - `sans` - Clean sans-serif font
 * - `serif` - Traditional serif font
 * - `mono` - Monospace font for code-like text
 *
 * @example
 * ```ts
 * import { DefaultFontStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyTextShapeProps {
 *   font: typeof DefaultFontStyle
 *   // other props...
 * }
 *
 * // Create a text shape with monospace font
 * const textShape = {
 *   // ... other properties
 *   props: {
 *     font: 'mono' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultFontStyle: EnumStyleProp<"draw" | "mono" | "sans" | "serif">;

/**
 * Default horizontal alignment style property used by tldraw shapes for text positioning.
 * Controls how text content is horizontally aligned within shape boundaries.
 *
 * Available values:
 * - `start` - Align text to the start (left in LTR, right in RTL)
 * - `middle` - Center text horizontally
 * - `end` - Align text to the end (right in LTR, left in RTL)
 * - `start-legacy` - Legacy start alignment (deprecated)
 * - `end-legacy` - Legacy end alignment (deprecated)
 * - `middle-legacy` - Legacy middle alignment (deprecated)
 *
 * @example
 * ```ts
 * import { DefaultHorizontalAlignStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyTextShapeProps {
 *   align: typeof DefaultHorizontalAlignStyle
 *   // other props...
 * }
 *
 * // Create a shape with center-aligned text
 * const textShape = {
 *   // ... other properties
 *   props: {
 *     align: 'middle' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultHorizontalAlignStyle: EnumStyleProp<"end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start">;

/**
 * Default shape schema configurations for all built-in tldraw shape types.
 * Each shape type includes its validation props and migration sequences.
 *
 * This object contains schema information for:
 * - arrow: Directional lines that can bind to other shapes
 * - bookmark: Website bookmark cards with preview information
 * - draw: Freehand drawing paths created with drawing tools
 * - embed: Embedded content from external services (YouTube, Figma, etc.)
 * - frame: Container shapes for organizing content
 * - geo: Geometric shapes (rectangles, ellipses, triangles, etc.)
 * - group: Logical groupings of multiple shapes
 * - highlight: Highlighting strokes from the highlighter tool
 * - image: Raster image shapes referencing image assets
 * - line: Multi-point lines and splines
 * - note: Sticky note shapes with text content
 * - text: Rich text shapes with formatting support
 * - video: Video shapes referencing video assets
 *
 * @public
 * @example
 * ```ts
 * import { createTLSchema, defaultShapeSchemas } from '@tldraw/tlschema'
 *
 * // Use all default shapes
 * const schema = createTLSchema({
 *   shapes: defaultShapeSchemas,
 * })
 *
 * // Use only specific default shapes
 * const minimalSchema = createTLSchema({
 *   shapes: {
 *     geo: defaultShapeSchemas.geo,
 *     text: defaultShapeSchemas.text,
 *   },
 * })
 * ```
 */
export declare const defaultShapeSchemas: {
    arrow: {
        migrations: MigrationSequence;
        props: RecordProps<TLArrowShape>;
    };
    bookmark: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLBookmarkShape>;
    };
    draw: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLDrawShape>;
    };
    embed: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLEmbedShape>;
    };
    frame: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLFrameShape>;
    };
    geo: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLGeoShape>;
    };
    group: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLGroupShape>;
    };
    highlight: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLHighlightShape>;
    };
    image: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLImageShape>;
    };
    line: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLLineShape>;
    };
    note: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLNoteShape>;
    };
    text: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLTextShape>;
    };
    video: {
        migrations: TLPropsMigrations;
        props: RecordProps<TLVideoShape>;
    };
};

/**
 * Default size style property used by tldraw shapes for scaling visual elements.
 * Controls the relative size of shape elements like stroke width, text size, and other proportional features.
 *
 * Available values:
 * - `s` - Small size
 * - `m` - Medium size (default)
 * - `l` - Large size
 * - `xl` - Extra large size
 *
 * @example
 * ```ts
 * import { DefaultSizeStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyShapeProps {
 *   size: typeof DefaultSizeStyle
 *   // other props...
 * }
 *
 * // Create a shape with large size
 * const shape = {
 *   // ... other properties
 *   props: {
 *     size: 'l' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultSizeStyle: EnumStyleProp<"l" | "m" | "s" | "xl">;

/**
 * Default text alignment style property used by tldraw text shapes.
 * Controls how text content is aligned within text-based shapes like text boxes and notes.
 *
 * Available values:
 * - `start` - Align text to the start (left in LTR, right in RTL)
 * - `middle` - Center text horizontally
 * - `end` - Align text to the end (right in LTR, left in RTL)
 *
 * @example
 * ```ts
 * import { DefaultTextAlignStyle } from '@tldraw/tlschema'
 *
 * // Use in text shape props definition
 * interface MyTextShapeProps {
 *   textAlign: typeof DefaultTextAlignStyle
 *   // other props...
 * }
 *
 * // Create a text shape with center alignment
 * const textShape = {
 *   // ... other properties
 *   props: {
 *     textAlign: 'middle' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultTextAlignStyle: EnumStyleProp<"end" | "middle" | "start">;

/**
 * Default vertical alignment style property used by tldraw shapes for text positioning.
 * Controls how text content is vertically aligned within shape boundaries.
 *
 * Available values:
 * - `start` - Align text to the top
 * - `middle` - Center text vertically (default)
 * - `end` - Align text to the bottom
 *
 * @example
 * ```ts
 * import { DefaultVerticalAlignStyle } from '@tldraw/tlschema'
 *
 * // Use in shape props definition
 * interface MyShapeProps {
 *   verticalAlign: typeof DefaultVerticalAlignStyle
 *   // other props...
 * }
 *
 * // Create a shape with top-aligned text
 * const shape = {
 *   // ... other properties
 *   props: {
 *     verticalAlign: 'start' as const,
 *     // ... other props
 *   }
 * }
 * ```
 *
 * @public
 */
export declare const DefaultVerticalAlignStyle: EnumStyleProp<"end" | "middle" | "start">;

/**
 * Record type definition for TLDocument with validation and default properties.
 * Configures the document as a document-scoped record that persists across sessions.
 *
 * @example
 * ```ts
 * // Create a document record (usually done automatically)
 * const documentRecord = DocumentRecordType.create({
 *   id: TLDOCUMENT_ID,
 *   name: 'My Drawing',
 *   gridSize: 20,
 *   meta: { createdAt: Date.now() }
 * })
 *
 * // Create with defaults
 * const defaultDocument = DocumentRecordType.create({
 *   id: TLDOCUMENT_ID
 *   // gridSize: 10, name: '', meta: {} are applied as defaults
 * })
 *
 * // Store the document
 * store.put([documentRecord])
 * ```
 *
 * @public
 */
export declare const DocumentRecordType: RecordType<TLDocument, never>;

/**
 * Migration sequence for draw shape properties across different schema versions.
 * Handles adding pen detection and scale properties to existing draw shapes.
 *
 * @public
 */
export declare const drawShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for draw shape properties.
 *
 * @public
 * @example
 * ```ts
 * // Validate draw shape properties
 * const props = {
 *   color: 'red',
 *   fill: 'solid',
 *   segments: [{ type: 'free', points: [] }],
 *   isComplete: true
 * }
 * const isValid = drawShapeProps.color.isValid(props.color)
 * ```
 */
export declare const drawShapeProps: RecordProps<TLDrawShape>;

/**
 * Defines the snapping behavior for elbow-style arrows when binding to shapes.
 * Controls how the arrow segment aligns with the target shape's geometry.
 *
 * @example
 * ```ts
 * const binding: TLArrowBindingProps = {
 *   terminal: 'end',
 *   normalizedAnchor: { x: 0.5, y: 0.5 },
 *   isExact: false,
 *   isPrecise: true,
 *   snap: 'edge' // Snap to shape edge
 * }
 * ```
 *
 * @public
 */
export declare const ElbowArrowSnap: T.Validator<"center" | "edge-point" | "edge" | "none">;

/**
 * Type representing the possible elbow arrow snap modes.
 *
 * - `'center'` - Snap to the center of the target shape
 * - `'edge-point'` - Snap to a specific point on the shape's edge
 * - `'edge'` - Snap to the nearest edge of the shape
 * - `'none'` - No snapping behavior
 *
 * @public
 */
export declare type ElbowArrowSnap = T.TypeOf<typeof ElbowArrowSnap>;

/**
 * Migration sequence for embed shape properties across different schema versions.
 * Handles URL transformations and removal of deprecated properties.
 *
 * @public
 */
export declare const embedShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for embed shape properties.
 *
 * @public
 * @example
 * ```ts
 * // Validate embed shape properties
 * const isValidUrl = embedShapeProps.url.isValid('https://youtube.com/watch?v=abc123')
 * const isValidSize = embedShapeProps.w.isValid(560)
 * ```
 */
export declare const embedShapeProps: RecordProps<TLEmbedShape>;

/**
 * See {@link StyleProp} & {@link StyleProp.defineEnum}
 *
 * @public
 */
export declare class EnumStyleProp<T> extends StyleProp<T> {
    readonly values: readonly T[];
    /* Excluded from this release type: __constructor */
}

/**
 * Migration sequence for frame shape properties across different schema versions.
 * Handles adding color properties to existing frame shapes.
 *
 * @public
 */
export declare const frameShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for frame shape properties.
 *
 * @public
 * @example
 * ```ts
 * // Validate frame properties
 * const isValidName = frameShapeProps.name.isValid('My Frame')
 * const isValidColor = frameShapeProps.color.isValid('red')
 * ```
 */
export declare const frameShapeProps: RecordProps<TLFrameShape>;

/**
 * Style property defining the geometric shape type for geo shapes.
 * Provides a variety of built-in geometric forms including basic shapes,
 * polygons, arrows, and special shapes.
 *
 * @public
 * @example
 * ```ts
 * // Use in shape props
 * const props = {
 *   geo: 'rectangle', // or 'ellipse', 'triangle', etc.
 *   // other properties...
 * }
 * ```
 */
export declare const GeoShapeGeoStyle: EnumStyleProp<"arrow-down" | "arrow-left" | "arrow-right" | "arrow-up" | "check-box" | "cloud" | "diamond" | "ellipse" | "heart" | "hexagon" | "octagon" | "oval" | "pentagon" | "rectangle" | "rhombus-2" | "rhombus" | "star" | "trapezoid" | "triangle" | "x-box">;

/**
 * Migration sequence for geo shape properties across different schema versions.
 * Handles evolution of geo shapes including URL support, label colors, alignment changes,
 * and the transition from plain text to rich text.
 *
 * @public
 */
export declare const geoShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for geo shape properties.
 *
 * @public
 * @example
 * ```ts
 * // Validate geo shape properties
 * const isValidGeo = geoShapeProps.geo.isValid('rectangle')
 * const isValidSize = geoShapeProps.w.isValid(100)
 * const isValidText = geoShapeProps.richText.isValid(toRichText('Hello'))
 * ```
 */
export declare const geoShapeProps: RecordProps<TLGeoShape>;

/**
 * Resolves a color style value to its actual CSS color string for a given theme and variant.
 * If the color is not a default theme color, returns the color value as-is.
 *
 * @param theme - The color theme to use for resolution
 * @param color - The color style value to resolve
 * @param variant - Which variant of the color to return (solid, fill, pattern, etc.)
 * @returns The CSS color string for the specified color and variant
 *
 * @example
 * ```ts
 * import { getColorValue, getDefaultColorTheme } from '@tldraw/tlschema'
 *
 * const theme = getDefaultColorTheme({ isDarkMode: false })
 *
 * // Get the solid variant of red
 * const redSolid = getColorValue(theme, 'red', 'solid') // '#e03131'
 *
 * // Get the fill variant of blue
 * const blueFill = getColorValue(theme, 'blue', 'fill') // '#4465e9'
 *
 * // Custom color passes through unchanged
 * const customColor = getColorValue(theme, '#ff0000', 'solid') // '#ff0000'
 * ```
 *
 * @public
 */
export declare function getColorValue(theme: TLDefaultColorTheme, color: TLDefaultColorStyle, variant: keyof TLDefaultColorThemeColor): string;

/**
 * Returns the appropriate default color theme based on the dark mode preference.
 *
 * @param opts - Configuration options
 *   - isDarkMode - Whether to return the dark theme (true) or light theme (false)
 * @returns The corresponding TLDefaultColorTheme (light or dark)
 *
 * @example
 * ```ts
 * import { getDefaultColorTheme } from '@tldraw/tlschema'
 *
 * // Get light theme
 * const lightTheme = getDefaultColorTheme({ isDarkMode: false })
 *
 * // Get dark theme
 * const darkTheme = getDefaultColorTheme({ isDarkMode: true })
 *
 * // Use with editor
 * const theme = getDefaultColorTheme({ isDarkMode: window.matchMedia('(prefers-color-scheme: dark)').matches })
 * ```
 *
 * @public
 */
export declare function getDefaultColorTheme(opts: {
    isDarkMode: boolean;
}): TLDefaultColorTheme;

/**
 * Gets the default translation locale based on the user's browser language preferences.
 *
 * This function determines the best matching locale from the user's browser language
 * settings, falling back to English if no suitable match is found. It works in both
 * browser and server-side environments, defaulting to English on the server.
 *
 * The function prioritizes exact matches first, then falls back to language-only
 * matches, and finally uses predefined regional defaults for languages like Chinese,
 * Portuguese, Korean, and Hindi.
 *
 * @returns The locale identifier (e.g., 'en', 'fr', 'zh-cn') that best matches the user's preferences
 *
 * @example
 * ```ts
 * import { getDefaultTranslationLocale } from '@tldraw/tlschema'
 *
 * // Get the user's preferred locale
 * const locale = getDefaultTranslationLocale()
 * console.log(locale) // e.g., "fr" or "en" or "zh-cn"
 *
 * // Use in localization setup
 * const i18n = new I18n({
 *   locale,
 *   // ... other config
 * })
 * ```
 *
 * @example
 * ```ts
 * // Browser with languages: ['fr-CA', 'en-US']
 * const locale = getDefaultTranslationLocale()
 * console.log(locale) // "fr" (if French is supported)
 *
 * // Browser with languages: ['zh']
 * const locale = getDefaultTranslationLocale()
 * console.log(locale) // "zh-cn" (default region for Chinese)
 * ```
 *
 * @public
 */
export declare function getDefaultTranslationLocale(): TLLanguage['locale'];

/**
 * Creates default presence state information for a user based on the current store state.
 *
 * This function extracts the current state from various store records (instance, page state,
 * camera, pointer) and combines them with user information to create a complete presence
 * state object. This is commonly used as a starting point for custom presence implementations.
 *
 * @param store - The tldraw store containing the current editor state
 * @param user - The user information to include in the presence state
 * @returns The default presence state info, or null if required store records are missing
 *
 * @example
 * ```ts
 * import { getDefaultUserPresence } from '@tldraw/tlschema'
 *
 * const user = { id: 'user-123', name: 'Alice', color: '#ff0000' }
 * const presenceInfo = getDefaultUserPresence(store, user)
 *
 * if (presenceInfo) {
 *   console.log('Current cursor:', presenceInfo.cursor)
 *   console.log('Selected shapes:', presenceInfo.selectedShapeIds)
 *   console.log('Camera position:', presenceInfo.camera)
 * }
 * ```
 *
 * @example
 * ```ts
 * // Common pattern: customize default presence
 * const customPresence = {
 *   ...getDefaultUserPresence(store, user),
 *   // Remove camera for privacy
 *   camera: undefined,
 *   // Add custom metadata
 *   customField: 'my-data'
 * }
 * ```
 *
 * @public
 */
export declare function getDefaultUserPresence(store: TLStore, user: TLPresenceUserInfo): {
    brush: BoxModel | null;
    camera: {
        x: number;
        y: number;
        z: number;
    };
    chatMessage: string;
    color: string;
    currentPageId: TLPageId;
    cursor: {
        rotation: number;
        type: string;
        x: number;
        y: number;
    };
    followingUserId: null | string;
    lastActivityTimestamp: number;
    meta: {};
    screenBounds: BoxModel;
    scribbles: TLScribble[];
    selectedShapeIds: TLShapeId[];
    userId: string;
    userName: string;
} | null;

/* Excluded from this release type: getShapePropKeysByStyle */

/**
 * Migration sequence for group shapes. Currently contains no migrations.
 *
 * @public
 */
export declare const groupShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for group shape properties. Since group shapes have no visual properties,
 * this is an empty object that serves as a placeholder for the schema system.
 *
 * @public
 * @example
 * ```ts
 * import { groupShapeProps } from '@tldraw/tlschema'
 *
 * // Used internally by the validation system
 * const validator = T.object(groupShapeProps)
 * ```
 */
export declare const groupShapeProps: RecordProps<TLGroupShape>;

/**
 * Migration sequence for highlight shapes. Handles schema evolution over time by defining
 * how to upgrade and downgrade highlight shape data between different versions.
 *
 * @public
 */
export declare const highlightShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for highlight shape properties. Defines the runtime validation rules
 * for all properties of highlight shapes.
 *
 * @public
 * @example
 * ```ts
 * import { highlightShapeProps } from '@tldraw/tlschema'
 *
 * // Used internally by the validation system
 * const validator = T.object(highlightShapeProps)
 * const validatedProps = validator.validate(someHighlightProps)
 * ```
 */
export declare const highlightShapeProps: RecordProps<TLHighlightShape>;

/**
 * Creates a validator for typed record IDs that ensures they follow the correct
 * format with the specified prefix. Record IDs in tldraw follow the pattern
 * "prefix:identifier" where the prefix indicates the record type.
 *
 * @param prefix - The required prefix for the ID (e.g., 'shape', 'page', 'asset')
 * @returns A validator that checks the ID format and returns the typed ID
 * @public
 * @example
 * ```ts
 * const shapeIdValidator = idValidator<TLShapeId>('shape')
 * const validId = shapeIdValidator.validate('shape:abc123') // Returns 'shape:abc123' as TLShapeId
 *
 * const pageIdValidator = idValidator<TLPageId>('page')
 * const pageId = pageIdValidator.validate('page:main') // Returns 'page:main' as TLPageId
 *
 * // This would throw an error:
 * // shapeIdValidator.validate('page:abc123') // Error: shape ID must start with "shape:"
 * ```
 */
export declare function idValidator<Id extends RecordId<UnknownRecord>>(prefix: Id['__type__']['typeName']): T.Validator<Id>;

/**
 * Validator for image shape crop data. Defines the structure for cropping an image,
 * specifying the visible region within the original image bounds.
 *
 * @public
 * @example
 * ```ts
 * const cropData: TLShapeCrop = {
 *   topLeft: { x: 0.1, y: 0.1 },
 *   bottomRight: { x: 0.9, y: 0.9 },
 *   isCircle: false
 * }
 *
 * const isValid = ImageShapeCrop.isValid(cropData)
 * ```
 */
export declare const ImageShapeCrop: T.ObjectValidator<TLShapeCrop>;

/**
 * Migration sequence for image shapes. Handles schema evolution over time by defining
 * how to upgrade and downgrade image shape data between different versions. Includes
 * migrations for URL properties, crop functionality, flip properties, and accessibility features.
 *
 * @public
 */
export declare const imageShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for image shape properties. Defines the runtime validation rules
 * for all properties of image shapes, ensuring data integrity and type safety.
 *
 * @public
 * @example
 * ```ts
 * import { imageShapeProps } from '@tldraw/tlschema'
 *
 * // Used internally by the validation system
 * const validator = T.object(imageShapeProps)
 * const validatedProps = validator.validate(someImageProps)
 * ```
 */
export declare const imageShapeProps: RecordProps<TLImageShape>;

/**
 * The RecordType definition for TLInstancePageState records. Defines validation,
 * scope, and default properties for instance page state records.
 *
 * Instance page states are scoped to the session level, meaning they are
 * specific to a browser tab and don't persist across sessions or sync
 * in collaborative environments.
 *
 * @example
 * ```ts
 * const pageState = InstancePageStateRecordType.create({
 *   id: 'instance_page_state:page1',
 *   pageId: 'page:page1',
 *   selectedShapeIds: ['shape:rect1']
 * })
 * ```
 *
 * @public
 */
export declare const InstancePageStateRecordType: RecordType<TLInstancePageState, "pageId">;

/**
 * The RecordType definition for TLInstancePresence records. Defines validation,
 * scope, and default properties for instance presence records.
 *
 * Instance presence records are scoped to the presence level, meaning they
 * represent real-time collaborative state that is ephemeral and tied to
 * active user sessions.
 *
 * @example
 * ```ts
 * const presence = InstancePresenceRecordType.create({
 *   id: 'instance_presence:user1',
 *   userId: 'user1',
 *   userName: 'Alice',
 *   color: '#FF6B6B',
 *   currentPageId: 'page:main'
 * })
 * ```
 *
 * @public
 */
export declare const InstancePresenceRecordType: RecordType<TLInstancePresence, "currentPageId" | "userId" | "userName">;

/**
 * Type guard to check if a record is a TLBinding.
 * Useful for filtering or type narrowing when working with mixed record types.
 *
 * @param record - The record to check
 * @returns True if the record is a binding, false otherwise
 *
 * @example
 * ```ts
 * // Filter bindings from mixed records
 * const allRecords = store.allRecords()
 * const bindings = allRecords.filter(isBinding)
 *
 * // Type guard usage
 * function processRecord(record: UnknownRecord) {
 *   if (isBinding(record)) {
 *     // record is now typed as TLBinding
 *     console.log(`Binding from ${record.fromId} to ${record.toId}`)
 *   }
 * }
 * ```
 *
 * @public
 */
export declare function isBinding(record?: UnknownRecord): record is TLBinding;

/**
 * Type guard to check if a string is a valid TLBindingId.
 * Validates that the ID follows the correct format for binding identifiers.
 *
 * @param id - The string to check
 * @returns True if the string is a valid binding ID, false otherwise
 *
 * @example
 * ```ts
 * // Validate binding IDs
 * const maybeBindingId = 'binding:abc123'
 * if (isBindingId(maybeBindingId)) {
 *   // maybeBindingId is now typed as TLBindingId
 *   const binding = store.get(maybeBindingId)
 * }
 *
 * // Filter binding IDs from mixed ID array
 * const mixedIds = ['shape:1', 'binding:2', 'page:3']
 * const bindingIds = mixedIds.filter(isBindingId)
 * ```
 *
 * @public
 */
export declare function isBindingId(id?: string): id is TLBindingId;

/**
 * Type guard to check if a record is a TLDocument.
 * Useful for filtering or type narrowing when working with mixed record types.
 *
 * @param record - The record to check
 * @returns True if the record is a document, false otherwise
 *
 * @example
 * ```ts
 * // Type guard usage
 * function processRecord(record: UnknownRecord) {
 *   if (isDocument(record)) {
 *     // record is now typed as TLDocument
 *     console.log(`Document: ${record.name}, Grid: ${record.gridSize}px`)
 *   }
 * }
 *
 * // Filter documents from mixed records
 * const allRecords = store.allRecords()
 * const documents = allRecords.filter(isDocument) // Should be exactly one
 * ```
 *
 * @public
 */
export declare function isDocument(record?: UnknownRecord): record is TLDocument;

/**
 * Type guard to check if a string is a valid TLPageId.
 *
 * @param id - The string to check
 * @returns True if the ID is a valid page ID, false otherwise
 *
 * @example
 * ```ts
 * if (isPageId('page:main')) {
 *   // TypeScript knows this is a TLPageId
 *   console.log('Valid page ID')
 * }
 * ```
 *
 * @public
 */
export declare function isPageId(id: string): id is TLPageId;

/**
 * Type guard to check if a record is a shape.
 *
 * @param record - The record to check
 * @returns True if the record is a shape, false otherwise
 *
 * @example
 * ```ts
 * const record = store.get('shape:abc123')
 * if (isShape(record)) {
 *   console.log(`Shape type: ${record.type}`)
 *   console.log(`Position: (${record.x}, ${record.y})`)
 * }
 * ```
 *
 * @public
 */
export declare function isShape(record?: UnknownRecord): record is TLShape;

/**
 * Type guard to check if a string is a valid shape ID.
 *
 * @param id - The string to check
 * @returns True if the string is a valid shape ID, false otherwise
 *
 * @example
 * ```ts
 * const id = 'shape:abc123'
 * if (isShapeId(id)) {
 *   const shape = store.get(id) // TypeScript knows id is TLShapeId
 * }
 *
 * // Check user input
 * function selectShape(id: string) {
 *   if (isShapeId(id)) {
 *     editor.selectShape(id)
 *   } else {
 *     console.error('Invalid shape ID format')
 *   }
 * }
 * ```
 *
 * @public
 */
export declare function isShapeId(id?: string): id is TLShapeId;

/** @public */
export declare const LANGUAGES: readonly [{
    readonly label: "Bahasa Indonesia";
    readonly locale: "id";
}, {
    readonly label: "Bahasa Melayu";
    readonly locale: "ms";
}, {
    readonly label: "Català";
    readonly locale: "ca";
}, {
    readonly label: "Čeština";
    readonly locale: "cs";
}, {
    readonly label: "Danish";
    readonly locale: "da";
}, {
    readonly label: "Deutsch";
    readonly locale: "de";
}, {
    readonly label: "English";
    readonly locale: "en";
}, {
    readonly label: "Español";
    readonly locale: "es";
}, {
    readonly label: "Filipino";
    readonly locale: "tl";
}, {
    readonly label: "Français";
    readonly locale: "fr";
}, {
    readonly label: "Galego";
    readonly locale: "gl";
}, {
    readonly label: "Hrvatski";
    readonly locale: "hr";
}, {
    readonly label: "Italiano";
    readonly locale: "it";
}, {
    readonly label: "Magyar";
    readonly locale: "hu";
}, {
    readonly label: "Nederlands";
    readonly locale: "nl";
}, {
    readonly label: "Norwegian";
    readonly locale: "no";
}, {
    readonly label: "Polski";
    readonly locale: "pl";
}, {
    readonly label: "Português - Brasil";
    readonly locale: "pt-br";
}, {
    readonly label: "Português - Europeu";
    readonly locale: "pt-pt";
}, {
    readonly label: "Română";
    readonly locale: "ro";
}, {
    readonly label: "Slovenščina";
    readonly locale: "sl";
}, {
    readonly label: "Somali";
    readonly locale: "so";
}, {
    readonly label: "Suomi";
    readonly locale: "fi";
}, {
    readonly label: "Svenska";
    readonly locale: "sv";
}, {
    readonly label: "Tiếng Việt";
    readonly locale: "vi";
}, {
    readonly label: "Türkçe";
    readonly locale: "tr";
}, {
    readonly label: "Ελληνικά";
    readonly locale: "el";
}, {
    readonly label: "Русский";
    readonly locale: "ru";
}, {
    readonly label: "Українська";
    readonly locale: "uk";
}, {
    readonly label: "עברית";
    readonly locale: "he";
}, {
    readonly label: "اردو";
    readonly locale: "ur";
}, {
    readonly label: "عربي";
    readonly locale: "ar";
}, {
    readonly label: "فارسی";
    readonly locale: "fa";
}, {
    readonly label: "नेपाली";
    readonly locale: "ne";
}, {
    readonly label: "मराठी";
    readonly locale: "mr";
}, {
    readonly label: "हिन्दी";
    readonly locale: "hi-in";
}, {
    readonly label: "বাংলা";
    readonly locale: "bn";
}, {
    readonly label: "ਪੰਜਾਬੀ";
    readonly locale: "pa";
}, {
    readonly label: "ગુજરાતી";
    readonly locale: "gu-in";
}, {
    readonly label: "தமிழ்";
    readonly locale: "ta";
}, {
    readonly label: "తెలుగు";
    readonly locale: "te";
}, {
    readonly label: "ಕನ್ನಡ";
    readonly locale: "kn";
}, {
    readonly label: "മലയാളം";
    readonly locale: "ml";
}, {
    readonly label: "ภาษาไทย";
    readonly locale: "th";
}, {
    readonly label: "ភាសាខ្មែរ";
    readonly locale: "km-kh";
}, {
    readonly label: "한국어";
    readonly locale: "ko-kr";
}, {
    readonly label: "日本語";
    readonly locale: "ja";
}, {
    readonly label: "简体中文";
    readonly locale: "zh-cn";
}, {
    readonly label: "繁體中文 (台灣)";
    readonly locale: "zh-tw";
}];

/**
 * Migration sequence for line shapes. Handles schema evolution over time by defining
 * how to upgrade and downgrade line shape data between different versions. Includes
 * major structural changes like the transition from handles to points and the addition
 * of scaling support.
 *
 * @public
 */
export declare const lineShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for line shape properties. Defines the runtime validation rules
 * for all properties of line shapes, ensuring data integrity and type safety.
 *
 * @public
 * @example
 * ```ts
 * import { lineShapeProps } from '@tldraw/tlschema'
 *
 * // Used internally by the validation system
 * const validator = T.object(lineShapeProps)
 * const validatedProps = validator.validate(someLineProps)
 * ```
 */
export declare const lineShapeProps: RecordProps<TLLineShape>;

/**
 * Style property for line shape spline interpolation. Determines how the line is rendered
 * between points - either as straight line segments or smooth cubic curves.
 *
 * @public
 * @example
 * ```ts
 * // Create a shape with cubic spline interpolation
 * const lineProps = {
 *   spline: 'cubic' as TLLineShapeSplineStyle,
 *   // other props...
 * }
 * ```
 */
export declare const LineShapeSplineStyle: EnumStyleProp<"cubic" | "line">;

/**
 * Migration sequence for note shapes. Handles schema evolution over time by defining
 * how to upgrade and downgrade note shape data between different versions. Includes
 * migrations for URL properties, text alignment changes, vertical alignment addition,
 * font size adjustments, scaling support, label color, and the transition from plain text to rich text.
 *
 * @public
 */
export declare const noteShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for note shape properties. Defines the runtime validation rules
 * for all properties of note shapes, ensuring data integrity and type safety.
 *
 * @public
 * @example
 * ```ts
 * import { noteShapeProps } from '@tldraw/tlschema'
 *
 * // Used internally by the validation system
 * const validator = T.object(noteShapeProps)
 * const validatedProps = validator.validate(someNoteProps)
 * ```
 */
export declare const noteShapeProps: RecordProps<TLNoteShape>;

/**
 * A validator for opacity values.
 *
 * This validator ensures that opacity values are numbers between 0 and 1 (inclusive).
 * Values outside this range will cause a validation error. The validator provides
 * runtime type checking for opacity properties throughout the editor.
 *
 * @param n - The number to validate as an opacity value
 * @throws T.ValidationError When the value is not between 0 and 1
 *
 * @example
 * ```ts
 * import { opacityValidator } from '@tldraw/tlschema'
 *
 * // Valid opacity values
 * try {
 *   const validOpacity1 = opacityValidator.validate(0.5) // ✓
 *   const validOpacity2 = opacityValidator.validate(1.0) // ✓
 *   const validOpacity3 = opacityValidator.validate(0.0) // ✓
 * } catch (error) {
 *   console.error('Validation failed:', error.message)
 * }
 *
 * // Invalid opacity values
 * try {
 *   opacityValidator.validate(-0.1) // ✗ Throws error
 *   opacityValidator.validate(1.5)  // ✗ Throws error
 * } catch (error) {
 *   console.error('Invalid opacity:', error.message)
 * }
 * ```
 *
 * @public
 */
export declare const opacityValidator: T.Validator<number>;

/**
 * Validator for TLPageId values. Ensures the ID follows the correct
 * format for page records ('page:' prefix).
 *
 * @example
 * ```ts
 * const isValid = pageIdValidator.isValid('page:main') // true
 * const isValid2 = pageIdValidator.isValid('shape:abc') // false
 * ```
 *
 * @public
 */
export declare const pageIdValidator: T.Validator<TLPageId>;

/**
 * The RecordType definition for TLPage records. Defines validation, scope,
 * and default properties for page records in the tldraw store.
 *
 * Pages are scoped to the document level, meaning they persist across sessions
 * and are shared in collaborative environments.
 *
 * @example
 * ```ts
 * const page = PageRecordType.create({
 *   id: 'page:main',
 *   name: 'Main Page',
 *   index: 'a1'
 * })
 * ```
 *
 * @public
 */
export declare const PageRecordType: RecordType<TLPage, "index" | "name">;

/**
 * Validator for parent IDs, ensuring they follow the correct format.
 *
 * Parent IDs must start with either "page:" (for shapes directly on a page)
 * or "shape:" (for shapes inside other shapes like frames or groups).
 *
 * @example
 * ```ts
 * // Valid parent IDs
 * const pageParent = parentIdValidator.validate('page:main') // ✓
 * const shapeParent = parentIdValidator.validate('shape:frame1') // ✓
 *
 * // Invalid parent ID (throws error)
 * const invalid = parentIdValidator.validate('invalid:123') // ✗
 * ```
 *
 * @public
 */
export declare const parentIdValidator: T.Validator<TLParentId>;

/* Excluded from this release type: pluckPreservingValues */

/**
 * The RecordType definition for TLPointer records. Defines validation,
 * scope, and default properties for pointer records in the tldraw store.
 *
 * Pointer records are scoped to the session level, meaning they are
 * specific to a browser tab and don't persist across sessions.
 *
 * @example
 * ```ts
 * const pointer = PointerRecordType.create({
 *   id: 'pointer:pointer',
 *   x: 0,
 *   y: 0
 * })
 * ```
 *
 * @public
 */
export declare const PointerRecordType: RecordType<TLPointer, never>;

/**
 * Maps a record's property types to their corresponding validators.
 *
 * This utility type takes a record type with a `props` object and creates
 * a mapping where each property key maps to a validator for that property's type.
 * This is used to define validation schemas for record properties.
 *
 * @example
 * ```ts
 * interface MyShape extends TLBaseShape<'custom', { width: number; color: string }> {}
 *
 * // Define validators for the shape properties
 * const myShapeProps: RecordProps<MyShape> = {
 *   width: T.number,
 *   color: T.string
 * }
 * ```
 *
 * @public
 */
export declare type RecordProps<R extends UnknownRecord & {
    props: object;
}> = {
    [K in keyof R['props']]: T.Validatable<R['props'][K]>;
};

/**
 * Extracts the TypeScript types from a record properties configuration.
 *
 * Takes a configuration object where values are validators and returns the
 * corresponding TypeScript types, with undefined values made optional.
 *
 * @example
 * ```ts
 * const shapePropsConfig = {
 *   width: T.number,
 *   height: T.number,
 *   color: T.optional(T.string)
 * }
 *
 * type ShapeProps = RecordPropsType<typeof shapePropsConfig>
 * // Result: { width: number; height: number; color?: string }
 * ```
 *
 * @public
 */
export declare type RecordPropsType<Config extends Record<string, T.Validatable<any>>> = MakeUndefinedOptional<{
    [K in keyof Config]: T.TypeOf<Config[K]>;
}>;

/**
 * Validator for TLRichText objects that ensures they have the correct structure
 * for document-based rich text content. Validates a document with a type field
 * and an array of content blocks.
 *
 * @public
 * @example
 * ```ts
 * const richText = { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello' }] }] }
 * const isValid = richTextValidator.check(richText) // true
 * ```
 */
export declare const richTextValidator: T.ObjectValidator<{
    content: unknown[];
    type: string;
}>;

/**
 * Migration sequence for the root binding record structure.
 * Currently empty as the binding schema has not required any migrations yet.
 *
 * @example
 * ```ts
 * // Migrations would be automatically applied when loading old documents
 * const migratedStore = migrator.migrateStoreSnapshot({
 *   schema: oldSchema,
 *   store: oldStoreSnapshot
 * })
 * ```
 *
 * @public
 */
export declare const rootBindingMigrations: MigrationSequence;

/**
 * Migration sequence for the root shape record type.
 *
 * This sequence defines how shape records should be transformed when migrating
 * between different schema versions. Each migration handles a specific version
 * upgrade, ensuring data compatibility across tldraw versions.
 *
 * @public
 */
export declare const rootShapeMigrations: MigrationSequence;

/**
 * Configuration information for a schema type (shape or binding), including its properties,
 * metadata, and migration sequences for data evolution over time.
 *
 * @public
 * @example
 * ```ts
 * import { arrowShapeMigrations, arrowShapeProps } from './shapes/TLArrowShape'
 *
 * const myShapeSchema: SchemaPropsInfo = {
 *   migrations: arrowShapeMigrations,
 *   props: arrowShapeProps,
 *   meta: {
 *     customField: T.string,
 *   },
 * }
 * ```
 */
export declare interface SchemaPropsInfo {
    /**
     * Migration sequences for handling data evolution over time. Can be legacy migrations,
     * props-specific migrations, or general migration sequences.
     */
    migrations?: LegacyMigrations | MigrationSequence | TLPropsMigrations;
    /**
     * Validation schema for the shape or binding properties. Maps property names to their validators.
     */
    props?: Record<string, StoreValidator<any>>;
    /**
     * Validation schema for metadata fields. Maps metadata field names to their validators.
     */
    meta?: Record<string, StoreValidator<any>>;
}

/**
 * A validator for TLScribble objects.
 *
 * This validator ensures that scribble objects have all required properties
 * with valid types and values. It validates the points array, size constraints,
 * color types, and state values according to the scribble system requirements.
 *
 * @example
 * ```ts
 * import { scribbleValidator } from '@tldraw/tlschema'
 *
 * // Validate a scribble object
 * try {
 *   const validScribble = scribbleValidator.validate({
 *     id: 'scribble-1',
 *     points: [{ x: 0, y: 0, z: 1 }, { x: 10, y: 10, z: 1 }],
 *     size: 3,
 *     color: 'black',
 *     opacity: 0.8,
 *     state: 'active',
 *     delay: 0,
 *     shrink: 0.05,
 *     taper: true
 *   })
 *   console.log('Valid scribble:', validScribble)
 * } catch (error) {
 *   console.error('Invalid scribble:', error.message)
 * }
 * ```
 *
 * @public
 */
export declare const scribbleValidator: T.ObjectValidator<TLScribble>;

/**
 * Utility type that extracts the value type from a Set type.
 *
 * This helper type uses conditional type inference to extract the element type
 * from a Set. It's useful when working with sets in type definitions where you
 * need to reference the type of elements contained within the set.
 *
 * The type uses TypeScript's `infer` keyword to capture the generic parameter
 * of the Set type, making it reusable across different Set types.
 *
 * @example
 * ```ts
 * import { SetValue } from '@tldraw/tlschema'
 *
 * // Extract value type from a Set type
 * type StringSet = Set<string>
 * type StringValue = SetValue<StringSet> // string
 *
 * type NumberSet = Set<number>
 * type NumberValue = SetValue<NumberSet> // number
 * ```
 *
 * @example
 * ```ts
 * // Usage with const sets
 * const COLORS = new Set(['red', 'green', 'blue'] as const)
 * type ColorSet = typeof COLORS
 * type Color = SetValue<ColorSet> // 'red' | 'green' | 'blue'
 *
 * // Function that accepts set values
 * function processColor(color: SetValue<typeof COLORS>) {
 *   // color is typed as 'red' | 'green' | 'blue'
 *   console.log(`Processing color: ${color}`)
 * }
 * ```
 *
 * @example
 * ```ts
 * // Complex usage with union types
 * const UI_COLORS = new Set(['selection-stroke', 'accent', 'muted'])
 * type UIColorSet = typeof UI_COLORS
 * type UIColor = SetValue<UIColorSet> // 'selection-stroke' | 'accent' | 'muted'
 *
 * // Validate color is in set
 * function isValidUIColor(color: string): color is UIColor {
 *   return UI_COLORS.has(color)
 * }
 * ```
 *
 * @public
 */
export declare type SetValue<T extends Set<any>> = T extends Set<infer U> ? U : never;

/**
 * Validator for shape IDs, ensuring they follow the "shape:" format.
 *
 * @example
 * ```ts
 * const validId = shapeIdValidator.validate('shape:abc123') // ✓
 * const invalidId = shapeIdValidator.validate('page:abc123') // ✗ throws error
 * ```
 *
 * @public
 */
export declare const shapeIdValidator: T.Validator<TLShapeId>;

/**
 * A shape type that supports cropping functionality.
 *
 * This type represents any shape that can display cropped content, typically media shapes
 * like images and videos. The shape has width, height, and optional crop parameters.
 * When crop is null, the entire asset is displayed.
 *
 * @example
 * ```ts
 * // An image shape with cropping
 * const croppedImageShape: ShapeWithCrop = {
 *   id: 'shape:image1',
 *   type: 'image',
 *   x: 100,
 *   y: 200,
 *   // ... other base shape properties
 *   props: {
 *     w: 300,
 *     h: 200,
 *     crop: {
 *       topLeft: { x: 0.1, y: 0.1 },
 *       bottomRight: { x: 0.9, y: 0.9 }
 *     }
 *   }
 * }
 *
 * // A shape without cropping (shows full asset)
 * const fullImageShape: ShapeWithCrop = {
 *   // ... shape properties
 *   props: {
 *     w: 400,
 *     h: 300,
 *     crop: null // Shows entire asset
 *   }
 * }
 * ```
 *
 * @public
 */
export declare type ShapeWithCrop = TLBaseShape<string, {
    crop: null | TLShapeCrop;
    h: number;
    w: number;
}>;

/**
 * A `StyleProp` is a property of a shape that follows some special rules.
 *
 * 1. The same value can be set on lots of shapes at the same time.
 *
 * 2. The last used value is automatically saved and applied to new shapes.
 *
 * For example, {@link DefaultColorStyle} is a style prop used by tldraw's default shapes to set
 * their color. If you try selecting several shapes on tldraw.com and changing their color, you'll
 * see that the color is applied to all of them. Then, if you draw a new shape, it'll have the same
 * color as the one you just set.
 *
 * You can use styles in your own shapes by either defining your own (see {@link StyleProp.define}
 * and {@link StyleProp.defineEnum}) or using tldraw's default ones, like {@link DefaultColorStyle}.
 * When you define a shape, pass a `props` object describing all of your shape's properties, using
 * `StyleProp`s for the ones you want to be styles. See the
 * {@link https://github.com/tldraw/tldraw/tree/main/apps/examples | custom styles example}
 * for more.
 *
 * @public
 */
export declare class StyleProp<Type> implements T.Validatable<Type> {
    readonly id: string;
    defaultValue: Type;
    readonly type: T.Validatable<Type>;
    /**
     * Define a new {@link StyleProp}.
     *
     * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
     * your app/library name.
     * @param options -
     * - `defaultValue`: The default value for this style prop.
     *
     * - `type`: Optionally, describe what type of data you expect for this style prop.
     *
     * @example
     * ```ts
     * import {T} from '@tldraw/validate'
     * import {StyleProp} from '@tldraw/tlschema'
     *
     * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
     *   defaultValue: 1,
     *   type: T.number,
     * })
     * ```
     * @public
     */
    static define<Type>(uniqueId: string, options: {
        defaultValue: Type;
        type?: T.Validatable<Type>;
    }): StyleProp<Type>;
    /**
     * Define a new {@link StyleProp} as a list of possible values.
     *
     * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
     * your app/library name.
     * @param options -
     * - `defaultValue`: The default value for this style prop.
     *
     * - `values`: An array of possible values of this style prop.
     *
     * @example
     * ```ts
     * import {StyleProp} from '@tldraw/tlschema'
     *
     * const MySizeProp = StyleProp.defineEnum('myApp:size', {
     *   defaultValue: 'medium',
     *   values: ['small', 'medium', 'large'],
     * })
     * ```
     */
    static defineEnum<const Values extends readonly unknown[]>(uniqueId: string, options: {
        defaultValue: Values[number];
        values: Values;
    }): EnumStyleProp<Values[number]>;
    /* Excluded from this release type: __constructor */
    setDefaultValue(value: Type): void;
    validate(value: unknown): Type;
    validateUsingKnownGoodVersion(prevValue: Type, newValue: unknown): Type;
}

/**
 * @public
 */
export declare type StylePropValue<T extends StyleProp<any>> = T extends StyleProp<infer U> ? U : never;

/**
 * Migration sequence for text shape schema evolution. This handles transforming
 * text shape data between different versions as the schema evolves over time.
 *
 * Key migrations include:
 * - RemoveJustify: Replaced 'justify' alignment with 'start'
 * - AddTextAlign: Migrated from 'align' to 'textAlign' property
 * - AddRichText: Converted plain text to rich text format
 *
 * @public
 */
export declare const textShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for text shape properties. This defines the runtime validation
 * rules that ensure text shape data integrity when records are stored or transmitted.
 *
 * @public
 * @example
 * ```ts
 * import { textShapeProps } from '@tldraw/tlschema'
 *
 * // Validate text shape properties
 * const isValid = textShapeProps.richText.isValid(myRichText)
 * if (isValid) {
 *   // Properties are valid, safe to use
 * }
 * ```
 */
export declare const textShapeProps: RecordProps<TLTextShape>;

/**
 * The colors used by tldraw's canvas UI system.
 *
 * These are special color types used for canvas UI elements like selections,
 * accents, and other interface components that overlay the drawing canvas.
 * Unlike shape colors, these are semantic color types that adapt to the
 * current theme.
 *
 * @example
 * ```ts
 * // Check if a color is a canvas UI color
 * if (TL_CANVAS_UI_COLOR_TYPES.has('selection-stroke')) {
 *   console.log('This is a valid canvas UI color')
 * }
 * ```
 *
 * @public
 */
export declare const TL_CANVAS_UI_COLOR_TYPES: Set<"accent" | "black" | "laser" | "muted-1" | "selection-fill" | "selection-stroke" | "white">;

/**
 * All available cursor types used throughout the tldraw editor.
 *
 * These cursor types correspond to CSS cursor values and are used to indicate
 * different interaction modes and states within the editor. The cursor types
 * cover selection, resizing, rotation, text editing, and various other editor
 * interactions.
 *
 * @example
 * ```ts
 * // Check if a cursor type is valid
 * if (TL_CURSOR_TYPES.has('resize-corner')) {
 *   console.log('Valid cursor type')
 * }
 *
 * // Get all available cursor types
 * const allCursors = Array.from(TL_CURSOR_TYPES)
 * ```
 *
 * @public
 */
export declare const TL_CURSOR_TYPES: Set<string>;

/**
 * All available handle types used by shapes in the tldraw editor.
 *
 * Handles are interactive control points on shapes that allow users to
 * modify the shape's geometry. Different handle types serve different purposes:
 *
 * - `vertex`: A control point that defines a vertex of the shape
 * - `virtual`: A handle that exists between vertices for adding new points
 * - `create`: A handle for creating new geometry (like extending a line)
 * - `clone`: A handle for duplicating or cloning shape elements
 *
 * @example
 * ```ts
 * // Check if a handle type is valid
 * if (TL_HANDLE_TYPES.has('vertex')) {
 *   console.log('Valid handle type')
 * }
 *
 * // Get all available handle types
 * const allHandleTypes = Array.from(TL_HANDLE_TYPES)
 * ```
 *
 * @public
 */
export declare const TL_HANDLE_TYPES: Set<"clone" | "create" | "vertex" | "virtual">;

/**
 * All available scribble states used by the tldraw drawing system.
 *
 * Scribble states represent the different phases of a drawing stroke:
 *
 * - `starting`: The scribble is being initiated
 * - `paused`: The scribble is temporarily paused
 * - `active`: The scribble is actively being drawn
 * - `stopping`: The scribble is being finished
 *
 * These states help manage the drawing lifecycle and apply appropriate
 * visual effects during different phases of the stroke.
 *
 * @example
 * ```ts
 * // Check if a scribble state is valid
 * if (TL_SCRIBBLE_STATES.has('active')) {
 *   console.log('Valid scribble state')
 * }
 *
 * // Get all available scribble states
 * const allStates = Array.from(TL_SCRIBBLE_STATES)
 * ```
 *
 * @public
 */
export declare const TL_SCRIBBLE_STATES: Set<"active" | "paused" | "starting" | "stopping">;

/**
 * Represents a binding relationship between an arrow shape and another shape.
 * Arrow bindings allow arrows to connect to and follow other shapes, maintaining
 * the connection even when shapes are moved or transformed.
 *
 * @example
 * ```ts
 * const arrowBinding: TLArrowBinding = {
 *   id: 'binding:abc123',
 *   typeName: 'binding',
 *   type: 'arrow',
 *   fromId: 'shape:arrow1', // The arrow shape
 *   toId: 'shape:rectangle1', // The target shape
 *   props: {
 *     terminal: 'end',
 *     normalizedAnchor: { x: 0.5, y: 0.5 },
 *     isExact: false,
 *     isPrecise: true,
 *     snap: 'edge'
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare type TLArrowBinding = TLBaseBinding<'arrow', TLArrowBindingProps>;

/**
 * Properties that define how an arrow binds to a target shape.
 * These properties control the visual and behavioral aspects of the arrow-to-shape connection.
 *
 * @example
 * ```ts
 * const arrowBindingProps: TLArrowBindingProps = {
 *   terminal: 'end', // Bind the arrow's end point
 *   normalizedAnchor: { x: 0.5, y: 0.0 }, // Bind to top center of shape
 *   isExact: true, // Arrow head enters the shape
 *   isPrecise: true, // Use exact anchor position
 *   snap: 'edge' // Snap to shape edge
 * }
 * ```
 *
 * @public
 */
export declare interface TLArrowBindingProps {
    /** Which end of the arrow is bound - either 'start' or 'end' */
    terminal: 'end' | 'start';
    /**
     * Normalized anchor point on the target shape (0,0 = top-left, 1,1 = bottom-right).
     * Coordinates are relative to the shape's bounding box.
     */
    normalizedAnchor: VecModel;
    /**
     * Whether the arrow head 'enters' the bound shape to point directly at the binding
     * anchor point. When true, the arrow head will be positioned inside the target shape.
     */
    isExact: boolean;
    /**
     * Whether to bind to the exact normalizedAnchor position, or to the center of the shape.
     * When false, the arrow will connect to the shape's center regardless of anchor position.
     */
    isPrecise: boolean;
    /** Snapping behavior for elbow-style arrows */
    snap: ElbowArrowSnap;
}

/**
 * A complete arrow shape record.
 *
 * Combines the base shape interface with arrow-specific properties to create
 * a full arrow shape that can be stored and manipulated in the editor.
 *
 * @example
 * ```ts
 * const arrowShape: TLArrowShape = {
 *   id: 'shape:arrow123',
 *   typeName: 'shape',
 *   type: 'arrow',
 *   x: 100,
 *   y: 200,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     kind: 'arc',
 *     start: { x: 0, y: 0 },
 *     end: { x: 150, y: 100 },
 *     // ... other props
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare type TLArrowShape = TLBaseShape<'arrow', TLArrowShapeProps>;

/**
 * The type representing arrowhead styles for both start and end of arrows.
 *
 * @public
 */
export declare type TLArrowShapeArrowheadStyle = T.TypeOf<typeof ArrowShapeArrowheadStartStyle>;

/**
 * The type representing arrow shape kinds.
 *
 * @public
 */
export declare type TLArrowShapeKind = T.TypeOf<typeof ArrowShapeKindStyle>;

/**
 * Properties specific to arrow shapes.
 *
 * Defines all the configurable aspects of an arrow shape, including visual styling,
 * geometry, text labeling, and positioning. Arrows can connect two points and
 * optionally display text labels.
 *
 * @example
 * ```ts
 * const arrowProps: TLArrowShapeProps = {
 *   kind: 'arc',
 *   labelColor: 'black',
 *   color: 'blue',
 *   fill: 'none',
 *   dash: 'solid',
 *   size: 'm',
 *   arrowheadStart: 'none',
 *   arrowheadEnd: 'arrow',
 *   font: 'draw',
 *   start: { x: 0, y: 0 },
 *   end: { x: 100, y: 100 },
 *   bend: 0.2,
 *   richText: toRichText('Label'),
 *   labelPosition: 0.5,
 *   scale: 1,
 *   elbowMidPoint: 0.5
 * }
 * ```
 *
 * @public
 */
export declare interface TLArrowShapeProps {
    kind: TLArrowShapeKind;
    labelColor: TLDefaultColorStyle;
    color: TLDefaultColorStyle;
    fill: TLDefaultFillStyle;
    dash: TLDefaultDashStyle;
    size: TLDefaultSizeStyle;
    arrowheadStart: TLArrowShapeArrowheadStyle;
    arrowheadEnd: TLArrowShapeArrowheadStyle;
    font: TLDefaultFontStyle;
    start: VecModel;
    end: VecModel;
    bend: number;
    richText: TLRichText;
    labelPosition: number;
    scale: number;
    elbowMidPoint: number;
}

/**
 * Union type representing all possible asset types in tldraw.
 * Assets represent external resources like images, videos, or bookmarks that can be referenced by shapes.
 *
 * @example
 * ```ts
 * const imageAsset: TLAsset = {
 *   id: 'asset:image123',
 *   typeName: 'asset',
 *   type: 'image',
 *   props: {
 *     src: 'https://example.com/image.jpg',
 *     w: 800,
 *     h: 600,
 *     mimeType: 'image/jpeg',
 *     isAnimated: false
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare type TLAsset = TLBookmarkAsset | TLImageAsset | TLVideoAsset;

/**
 * Context information provided when resolving asset URLs, containing details about
 * the current rendering environment and user's connection to optimize asset delivery.
 *
 * @public
 * @example
 * ```ts
 * const assetStore: TLAssetStore = {
 *   async resolve(asset, context: TLAssetContext) {
 *     // Use low resolution for slow connections
 *     if (context.networkEffectiveType === 'slow-2g') {
 *       return `${asset.props.src}?quality=low`
 *     }
 *     // Use high DPI version for retina displays
 *     if (context.dpr > 1) {
 *       return `${asset.props.src}@2x`
 *     }
 *     return asset.props.src
 *   }
 * }
 * ```
 */
export declare interface TLAssetContext {
    /**
     * The scale at which the asset is being rendered on-screen relative to its native dimensions.
     * If the asset is 1000px wide, but it's been resized/zoom so it takes 500px on-screen, this
     * will be 0.5.
     *
     * The scale measures CSS pixels, not device pixels.
     */
    screenScale: number;
    /** The {@link TLAssetContext.screenScale}, stepped to the nearest power-of-2 multiple. */
    steppedScreenScale: number;
    /** The device pixel ratio - how many CSS pixels are in one device pixel? */
    dpr: number;
    /**
     * An alias for
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType | `navigator.connection.effectiveType` }
     * if it's available in the current browser. Use this to e.g. serve lower-resolution images to
     * users on slow connections.
     */
    networkEffectiveType: null | string;
    /**
     * In some circumstances, we need to resolve a URL that points to the original version of a
     * particular asset. This is used when the asset will leave the current tldraw instance - e.g.
     * for copy/paste, or exports.
     */
    shouldResolveToOriginal: boolean;
}

/**
 * Branded string type for asset record identifiers.
 * Prevents mixing asset IDs with other types of record IDs at compile time.
 *
 * @example
 * ```ts
 * import { createAssetId } from '@tldraw/tlschema'
 *
 * // Create a new asset ID
 * const assetId: TLAssetId = createAssetId()
 *
 * // Use in asset records
 * const asset: TLAsset = {
 *   id: assetId,
 *   // ... other properties
 * }
 *
 * // Reference in shapes
 * const imageShape: TLImageShape = {
 *   props: {
 *     assetId: assetId,
 *     // ... other properties
 *   }
 * }
 * ```
 *
 * @public
 */
export declare type TLAssetId = RecordId<TLBaseAsset<any, any>>;

/**
 * Partial type for TLAsset allowing optional properties except id and type.
 * Useful for creating or updating assets where not all properties need to be specified.
 *
 * @example
 * ```ts
 * // Create a partial asset for updating
 * const partialAsset: TLAssetPartial<TLImageAsset> = {
 *   id: 'asset:image123',
 *   type: 'image',
 *   props: {
 *     w: 800 // Only updating width
 *   }
 * }
 *
 * // Use in asset updates
 * editor.updateAssets([partialAsset])
 * ```
 *
 * @public
 */
export declare type TLAssetPartial<T extends TLAsset = TLAsset> = T extends T ? {
    id: TLAssetId;
    meta?: Partial<T['meta']>;
    props?: Partial<T['props']>;
    type: T['type'];
} & Partial<Omit<T, 'id' | 'meta' | 'props' | 'type'>> : never;

/**
 * Union type of all shapes that reference assets through an assetId property.
 * Includes image shapes, video shapes, and any other shapes that depend on external assets.
 *
 * @example
 * ```ts
 * // Function that works with any asset-based shape
 * function handleAssetShape(shape: TLAssetShape) {
 *   const assetId = shape.props.assetId
 *   if (assetId) {
 *     const asset = editor.getAsset(assetId)
 *     // Handle the asset...
 *   }
 * }
 *
 * // Use with image or video shapes
 * const imageShape: TLImageShape = { props: { assetId: 'asset:img1' } }
 * const videoShape: TLVideoShape = { props: { assetId: 'asset:vid1' } }
 * handleAssetShape(imageShape) // Works
 * handleAssetShape(videoShape) // Works
 * ```
 *
 * @public
 */
export declare type TLAssetShape = Extract<TLShape, {
    props: {
        assetId: TLAssetId;
    };
}>;

/**
 * Interface for storing and managing assets (images, videos, etc.) in tldraw.
 * Provides methods for uploading, resolving, and removing assets from storage.
 *
 * A `TLAssetStore` sits alongside the main {@link TLStore} and is responsible for storing and
 * retrieving large assets such as images. Generally, this should be part of a wider sync system:
 *
 * - By default, the store is in-memory only, so `TLAssetStore` converts images to data URLs
 * - When using
 *   {@link @tldraw/editor#TldrawEditorWithoutStoreProps.persistenceKey | `persistenceKey`}, the
 *   store is synced to the browser's local IndexedDB, so `TLAssetStore` stores images there too
 * - When using a multiplayer sync server, you would implement `TLAssetStore` to upload images to
 *   e.g. an S3 bucket.
 *
 * @public
 * @example
 * ```ts
 * // Simple in-memory asset store
 * const assetStore: TLAssetStore = {
 *   async upload(asset, file) {
 *     const dataUrl = await fileToDataUrl(file)
 *     return { src: dataUrl }
 *   },
 *
 *   async resolve(asset, context) {
 *     return asset.props.src
 *   },
 *
 *   async remove(assetIds) {
 *     // Clean up if needed
 *   }
 * }
 * ```
 */
export declare interface TLAssetStore {
    /**
     * Upload an asset to your storage, returning a URL that can be used to refer to the asset
     * long-term.
     *
     * @param asset - Information & metadata about the asset being uploaded
     * @param file - The `File` to be uploaded
     * @returns A promise that resolves to the URL of the uploaded asset
     */
    upload(asset: TLAsset, file: File, abortSignal?: AbortSignal): Promise<{
        meta?: JsonObject;
        src: string;
    }>;
    /**
     * Resolve an asset to a URL. This is used when rendering the asset in the editor. By default,
     * this will just use `asset.props.src`, the URL returned by `upload()`. This can be used to
     * rewrite that URL to add access credentials, or optimized the asset for how it's currently
     * being displayed using the {@link TLAssetContext | information provided}.
     *
     * @param asset - the asset being resolved
     * @param ctx - information about the current environment and where the asset is being used
     * @returns The URL of the resolved asset, or `null` if the asset is not available
     */
    resolve?(asset: TLAsset, ctx: TLAssetContext): null | Promise<null | string> | string;
    /**
     * Remove an asset from storage. This is called when the asset is no longer needed, e.g. when
     * the user deletes it from the editor.
     * @param asset - the asset being removed
     * @returns A promise that resolves when the asset has been removed
     */
    remove?(assetIds: TLAssetId[]): Promise<void>;
}

/**
 * Base interface for all asset records in tldraw. Assets represent external resources
 * like images, videos, or bookmarks that shapes can reference. This interface extends
 * the base record system with asset-specific typing.
 *
 * @param Type - The specific asset type identifier (e.g., 'image', 'video', 'bookmark')
 * @param Props - The properties object specific to this asset type
 *
 * @example
 * ```ts
 * // Define a custom asset type
 * interface MyCustomAsset extends TLBaseAsset<'custom', { url: string; title: string }> {}
 *
 * const customAsset: MyCustomAsset = {
 *   id: 'asset:custom123',
 *   typeName: 'asset',
 *   type: 'custom',
 *   props: {
 *     url: 'https://example.com',
 *     title: 'My Custom Asset'
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare interface TLBaseAsset<Type extends string, Props> extends BaseRecord<'asset', TLAssetId> {
    /** The specific type of this asset (e.g., 'image', 'video', 'bookmark') */
    type: Type;
    /** Type-specific properties for this asset */
    props: Props;
    /** User-defined metadata that can be attached to this asset */
    meta: JsonObject;
}

/**
 * Base interface for all binding types in tldraw. Bindings represent relationships
 * between shapes, such as arrows connecting to other shapes or organizational connections.
 *
 * All bindings extend this base interface with specific type and property definitions.
 * The binding system enables shapes to maintain relationships that persist through
 * transformations, movements, and other operations.
 *
 * @param Type - String literal type identifying the specific binding type (e.g., 'arrow')
 * @param Props - Object containing binding-specific properties and configuration
 *
 * @example
 * ```ts
 * // Define a custom binding type
 * interface MyCustomBinding extends TLBaseBinding<'custom', MyCustomProps> {}
 *
 * interface MyCustomProps {
 *   strength: number
 *   color: string
 * }
 *
 * // Create a binding instance
 * const binding: MyCustomBinding = {
 *   id: 'binding:abc123',
 *   typeName: 'binding',
 *   type: 'custom',
 *   fromId: 'shape:source1',
 *   toId: 'shape:target1',
 *   props: {
 *     strength: 0.8,
 *     color: 'red'
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare interface TLBaseBinding<Type extends string, Props extends object> extends BaseRecord<'binding', TLBindingId> {
    /** The specific type of this binding (e.g., 'arrow', 'custom') */
    type: Type;
    /** ID of the source shape in this binding relationship */
    fromId: TLShapeId;
    /** ID of the target shape in this binding relationship */
    toId: TLShapeId;
    /** Binding-specific properties that define behavior and appearance */
    props: Props;
    /** User-defined metadata for extending binding functionality */
    meta: JsonObject;
}

/**
 * Base interface for all shapes in tldraw.
 *
 * This interface defines the common properties that all shapes share, regardless of their
 * specific type. Every shape extends this base with additional type-specific properties.
 *
 * @example
 * ```ts
 * // Define a custom shape type
 * interface MyCustomShape extends TLBaseShape<'custom', { size: number; color: string }> {}
 *
 * // Create a shape instance
 * const myShape: MyCustomShape = {
 *   id: 'shape:abc123',
 *   typeName: 'shape',
 *   type: 'custom',
 *   x: 100,
 *   y: 200,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     size: 50,
 *     color: 'blue'
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare interface TLBaseShape<Type extends string, Props extends object> extends BaseRecord<'shape', TLShapeId> {
    type: Type;
    x: number;
    y: number;
    rotation: number;
    index: IndexKey;
    parentId: TLParentId;
    isLocked: boolean;
    opacity: TLOpacityType;
    props: Props;
    meta: JsonObject;
}

/**
 * The set of all bindings that are available in the editor, including unknown bindings.
 * Bindings represent relationships between shapes, such as arrows connecting to other shapes.
 *
 * @example
 * ```ts
 * // Check binding type and handle accordingly
 * function handleBinding(binding: TLBinding) {
 *   switch (binding.type) {
 *     case 'arrow':
 *       // Handle arrow binding
 *       break
 *     default:
 *       // Handle unknown custom binding
 *       break
 *   }
 * }
 * ```
 *
 * @public
 */
export declare type TLBinding = TLDefaultBinding | TLUnknownBinding;

/**
 * Type for creating new bindings with required fromId and toId.
 * The id is optional and will be generated if not provided.
 *
 * @example
 * ```ts
 * // Create a new arrow binding
 * const newBinding: TLBindingCreate<TLArrowBinding> = {
 *   type: 'arrow',
 *   fromId: 'shape:arrow1',
 *   toId: 'shape:rectangle1',
 *   props: {
 *     terminal: 'end',
 *     normalizedAnchor: { x: 0.5, y: 0.5 },
 *     isExact: false,
 *     isPrecise: true
 *   }
 * }
 *
 * editor.createBindings([newBinding])
 * ```
 *
 * @public
 */
export declare type TLBindingCreate<T extends TLBinding = TLBinding> = Expand<{
    fromId: T['fromId'];
    id?: TLBindingId;
    meta?: Partial<T['meta']>;
    props?: Partial<T['props']>;
    toId: T['toId'];
    type: T['type'];
    typeName?: T['typeName'];
}>;

/**
 * Branded string type for binding record identifiers.
 * Prevents mixing binding IDs with other types of record IDs at compile time.
 *
 * @example
 * ```ts
 * import { createBindingId } from '@tldraw/tlschema'
 *
 * // Create a new binding ID
 * const bindingId: TLBindingId = createBindingId()
 *
 * // Use in binding records
 * const binding: TLBinding = {
 *   id: bindingId,
 *   type: 'arrow',
 *   fromId: 'shape:arrow1',
 *   toId: 'shape:rectangle1',
 *   // ... other properties
 * }
 * ```
 *
 * @public
 */
export declare type TLBindingId = RecordId<TLUnknownBinding>;

/**
 * Type for updating existing bindings with partial properties.
 * Only the id and type are required, all other properties are optional.
 *
 * @example
 * ```ts
 * // Update arrow binding properties
 * const bindingUpdate: TLBindingUpdate<TLArrowBinding> = {
 *   id: 'binding:arrow1',
 *   type: 'arrow',
 *   props: {
 *     normalizedAnchor: { x: 0.7, y: 0.3 } // Only update anchor position
 *   }
 * }
 *
 * editor.updateBindings([bindingUpdate])
 * ```
 *
 * @public
 */
export declare type TLBindingUpdate<T extends TLBinding = TLBinding> = Expand<{
    fromId?: T['fromId'];
    id: TLBindingId;
    meta?: Partial<T['meta']>;
    props?: Partial<T['props']>;
    toId?: T['toId'];
    type: T['type'];
    typeName?: T['typeName'];
}>;

/**
 * An asset used for URL bookmarks, used by the TLBookmarkShape.
 *
 *  @public */
export declare type TLBookmarkAsset = TLBaseAsset<'bookmark', {
    description: string;
    favicon: string;
    image: string;
    src: null | string;
    title: string;
}>;

/**
 * A bookmark shape represents a website link with optional preview content.
 * Bookmark shapes display as cards showing the page title, description, and preview image.
 *
 * @public
 * @example
 * ```ts
 * const bookmarkShape: TLBookmarkShape = {
 *   id: createShapeId(),
 *   typeName: 'shape',
 *   type: 'bookmark',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:page1',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     w: 300,
 *     h: 320,
 *     assetId: 'asset:bookmark123',
 *     url: 'https://www.example.com'
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLBookmarkShape = TLBaseShape<'bookmark', TLBookmarkShapeProps>;

/**
 * Properties for the bookmark shape, which displays website bookmarks as interactive cards.
 *
 * @public
 */
export declare interface TLBookmarkShapeProps {
    /** Width of the bookmark shape in pixels */
    w: number;
    /** Height of the bookmark shape in pixels */
    h: number;
    /** Asset ID for the bookmark's preview image, or null if no image is available */
    assetId: null | TLAssetId;
    /** The URL that this bookmark points to */
    url: string;
}

/**
 * A camera record representing the viewport's position and zoom level.
 * The camera defines what portion of the infinite canvas is visible to the user.
 *
 * @example
 * ```ts
 * const camera: TLCamera = {
 *   id: 'camera:user1',
 *   typeName: 'camera',
 *   x: 100,    // Camera x position (negative values pan right)
 *   y: 50,     // Camera y position (negative values pan down)
 *   z: 0.5,    // Zoom level (1 = 100%, 0.5 = 50%, 2 = 200%)
 *   meta: {
 *     userId: 'user123',
 *     lastUpdated: Date.now()
 *   }
 * }
 *
 * // Set camera position and zoom
 * editor.setCamera({ x: -200, y: -100, z: 1.5 })
 * ```
 *
 * @public
 */
export declare interface TLCamera extends BaseRecord<'camera', TLCameraId> {
    /** Camera x position. Negative values move the viewport right */
    x: number;
    /** Camera y position. Negative values move the viewport down */
    y: number;
    /** Zoom level. 1 = 100%, 0.5 = 50% zoom, 2 = 200% zoom */
    z: number;
    /** User-defined metadata for the camera */
    meta: JsonObject;
}

/**
 * Branded string type for camera record identifiers.
 * Prevents mixing camera IDs with other types of record IDs at compile time.
 *
 * @example
 * ```ts
 * import { CameraRecordType } from '@tldraw/tlschema'
 *
 * // Create a camera ID (typically one per user/session)
 * const cameraId: TLCameraId = CameraRecordType.createId()
 *
 * // Use in camera records
 * const camera: TLCamera = {
 *   id: cameraId,
 *   typeName: 'camera',
 *   x: 0, y: 0, z: 1,
 *   meta: {}
 * }
 *
 * // Get camera from store
 * const currentCamera = store.get(cameraId)
 * ```
 *
 * @public
 */
export declare type TLCameraId = RecordId<TLCamera>;

/**
 * A union type representing the available canvas UI color types.
 *
 * Canvas UI colors are semantic color types used for interface elements
 * that overlay the drawing canvas, such as selection indicators, accents,
 * and other UI components.
 *
 * @example
 * ```ts
 * const selectionColor: TLCanvasUiColor = 'selection-stroke'
 * const accentColor: TLCanvasUiColor = 'accent'
 * const backgroundColor: TLCanvasUiColor = 'white'
 * ```
 *
 * @public
 */
export declare type TLCanvasUiColor = SetValue<typeof TL_CANVAS_UI_COLOR_TYPES>;

/**
 * A cursor object used throughout the tldraw editor.
 *
 * Represents both the cursor type (which determines the visual appearance)
 * and its rotation angle. The rotation is particularly useful for resize
 * and rotation cursors that need to align with the current interaction angle.
 *
 * @example
 * ```ts
 * // Default cursor
 * const defaultCursor: TLCursor = {
 *   type: 'default',
 *   rotation: 0
 * }
 *
 * // Rotated resize cursor
 * const rotatedResizeCursor: TLCursor = {
 *   type: 'resize-corner',
 *   rotation: Math.PI / 4 // 45 degrees
 * }
 *
 * // Text editing cursor
 * const textCursor: TLCursor = {
 *   type: 'text',
 *   rotation: 0
 * }
 * ```
 *
 * @public
 */
export declare interface TLCursor {
    /** The cursor type, determining the visual appearance and interaction mode */
    type: TLCursorType;
    /** The rotation angle in radians, used for rotated cursors like resize handles */
    rotation: number;
}

/**
 * A union type representing all available cursor types in the tldraw editor.
 *
 * Each cursor type corresponds to a different interaction mode or state,
 * helping users understand what action they can perform at any given moment.
 *
 * @example
 * ```ts
 * const defaultCursor: TLCursorType = 'default'
 * const textCursor: TLCursorType = 'text'
 * const resizeCursor: TLCursorType = 'resize-corner'
 * const rotateCursor: TLCursorType = 'nesw-rotate'
 * ```
 *
 * @public
 */
export declare type TLCursorType = SetValue<typeof TL_CURSOR_TYPES>;

/**
 * The default set of bindings that are available in the editor.
 * Currently includes only arrow bindings, but can be extended with custom bindings.
 *
 * @example
 * ```ts
 * // Arrow binding connects an arrow to shapes
 * const arrowBinding: TLDefaultBinding = {
 *   id: 'binding:arrow1',
 *   typeName: 'binding',
 *   type: 'arrow',
 *   fromId: 'shape:arrow1',
 *   toId: 'shape:rectangle1',
 *   props: {
 *     terminal: 'end',
 *     normalizedAnchor: { x: 0.5, y: 0.5 },
 *     isExact: false,
 *     isPrecise: true
 *   }
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultBinding = TLArrowBinding;

/**
 * Type representing a default color style value.
 * This is a union type of all available default color names.
 *
 * @example
 * ```ts
 * import { TLDefaultColorStyle } from '@tldraw/tlschema'
 *
 * // Valid color values
 * const redColor: TLDefaultColorStyle = 'red'
 * const blueColor: TLDefaultColorStyle = 'blue'
 *
 * // Type guard usage
 * function isValidColor(color: string): color is TLDefaultColorStyle {
 *   return ['black', 'red', 'blue'].includes(color as TLDefaultColorStyle)
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultColorStyle = T.TypeOf<typeof DefaultColorStyle>;

/**
 * Complete color theme definition containing all colors and their variants
 * for either light or dark mode. Includes base theme properties and all
 * default colors with their respective color variants.
 *
 * @example
 * ```ts
 * import { TLDefaultColorTheme } from '@tldraw/tlschema'
 *
 * const customTheme: TLDefaultColorTheme = {
 *   id: 'light',
 *   text: '#000000',
 *   background: '#ffffff',
 *   solid: '#fcfffe',
 *   black: { solid: '#000000', semi: '#cccccc', ... },
 *   // ... other colors
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultColorTheme = Expand<{
    background: string;
    id: 'dark' | 'light';
    solid: string;
    text: string;
} & Record<(typeof defaultColorNames)[number], TLDefaultColorThemeColor>>;

/**
 * Defines the color variants available for each color in the default theme.
 * Each color has multiple variants for different use cases like fills, strokes,
 * patterns, and UI elements like frames and notes.
 *
 * @example
 * ```ts
 * import { TLDefaultColorThemeColor } from '@tldraw/tlschema'
 *
 * const blueColor: TLDefaultColorThemeColor = {
 *   solid: '#4465e9',
 *   semi: '#dce1f8',
 *   pattern: '#6681ee',
 *   fill: '#4465e9',
 *   // ... other variants
 * }
 * ```
 *
 * @public
 */
export declare interface TLDefaultColorThemeColor {
    solid: string;
    semi: string;
    pattern: string;
    fill: string;
    frameHeadingStroke: string;
    frameHeadingFill: string;
    frameStroke: string;
    frameFill: string;
    frameText: string;
    noteFill: string;
    noteText: string;
    highlightSrgb: string;
    highlightP3: string;
}

/**
 * Type representing a default dash style value.
 * This is a union type of all available dash style options.
 *
 * @example
 * ```ts
 * import { TLDefaultDashStyle } from '@tldraw/tlschema'
 *
 * // Valid dash style values
 * const drawStyle: TLDefaultDashStyle = 'draw'
 * const solidStyle: TLDefaultDashStyle = 'solid'
 * const dashedStyle: TLDefaultDashStyle = 'dashed'
 * const dottedStyle: TLDefaultDashStyle = 'dotted'
 *
 * // Use in a function parameter
 * function setShapeDash(dash: TLDefaultDashStyle) {
 *   // Apply dash style to shape
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultDashStyle = T.TypeOf<typeof DefaultDashStyle>;

/**
 * Type representing a default fill style value.
 * This is a union type of all available fill style options.
 *
 * @example
 * ```ts
 * import { TLDefaultFillStyle } from '@tldraw/tlschema'
 *
 * // Valid fill style values
 * const noFill: TLDefaultFillStyle = 'none'
 * const solidFill: TLDefaultFillStyle = 'solid'
 * const patternFill: TLDefaultFillStyle = 'pattern'
 *
 * // Use in a function parameter
 * function setShapeFill(fill: TLDefaultFillStyle) {
 *   // Apply fill style to shape
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultFillStyle = T.TypeOf<typeof DefaultFillStyle>;

/**
 * Type representing a default font style value.
 * This is a union type of all available font style options.
 *
 * @example
 * ```ts
 * import { TLDefaultFontStyle } from '@tldraw/tlschema'
 *
 * // Valid font style values
 * const drawFont: TLDefaultFontStyle = 'draw'
 * const sansFont: TLDefaultFontStyle = 'sans'
 * const serifFont: TLDefaultFontStyle = 'serif'
 * const monoFont: TLDefaultFontStyle = 'mono'
 *
 * // Use in a function parameter
 * function setTextFont(font: TLDefaultFontStyle) {
 *   // Apply font style to text
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultFontStyle = T.TypeOf<typeof DefaultFontStyle>;

/**
 * Type representing a default horizontal alignment style value.
 * This is a union type of all available horizontal alignment options.
 *
 * @example
 * ```ts
 * import { TLDefaultHorizontalAlignStyle } from '@tldraw/tlschema'
 *
 * // Valid horizontal alignment values
 * const leftAlign: TLDefaultHorizontalAlignStyle = 'start'
 * const centerAlign: TLDefaultHorizontalAlignStyle = 'middle'
 * const rightAlign: TLDefaultHorizontalAlignStyle = 'end'
 *
 * // Use in a function parameter
 * function setTextAlignment(align: TLDefaultHorizontalAlignStyle) {
 *   // Apply horizontal alignment to text
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultHorizontalAlignStyle = T.TypeOf<typeof DefaultHorizontalAlignStyle>;

/**
 * The default set of shapes that are available in the editor.
 *
 * This union type represents all the built-in shape types supported by tldraw,
 * including arrows, bookmarks, drawings, embeds, frames, geometry shapes,
 * groups, images, lines, notes, text, videos, and highlights.
 *
 * @example
 * ```ts
 * // Check if a shape is a default shape type
 * function isDefaultShape(shape: TLShape): shape is TLDefaultShape {
 *   const defaultTypes = ['arrow', 'bookmark', 'draw', 'embed', 'frame', 'geo', 'group', 'image', 'line', 'note', 'text', 'video', 'highlight']
 *   return defaultTypes.includes(shape.type)
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultShape = TLArrowShape | TLBookmarkShape | TLDrawShape | TLEmbedShape | TLFrameShape | TLGeoShape | TLGroupShape | TLHighlightShape | TLImageShape | TLLineShape | TLNoteShape | TLTextShape | TLVideoShape;

/**
 * Type representing a default size style value.
 * This is a union type of all available size options.
 *
 * @example
 * ```ts
 * import { TLDefaultSizeStyle } from '@tldraw/tlschema'
 *
 * // Valid size values
 * const smallSize: TLDefaultSizeStyle = 's'
 * const mediumSize: TLDefaultSizeStyle = 'm'
 * const largeSize: TLDefaultSizeStyle = 'l'
 * const extraLargeSize: TLDefaultSizeStyle = 'xl'
 *
 * // Use in a function parameter
 * function setShapeSize(size: TLDefaultSizeStyle) {
 *   // Apply size style to shape
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultSizeStyle = T.TypeOf<typeof DefaultSizeStyle>;

/**
 * Type representing a default text alignment style value.
 * This is a union type of all available text alignment options.
 *
 * @example
 * ```ts
 * import { TLDefaultTextAlignStyle } from '@tldraw/tlschema'
 *
 * // Valid text alignment values
 * const leftAlign: TLDefaultTextAlignStyle = 'start'
 * const centerAlign: TLDefaultTextAlignStyle = 'middle'
 * const rightAlign: TLDefaultTextAlignStyle = 'end'
 *
 * // Use in a function parameter
 * function setTextAlignment(align: TLDefaultTextAlignStyle) {
 *   // Apply text alignment to text shape
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultTextAlignStyle = T.TypeOf<typeof DefaultTextAlignStyle>;

/**
 * Type representing a default vertical alignment style value.
 * This is a union type of all available vertical alignment options.
 *
 * @example
 * ```ts
 * import { TLDefaultVerticalAlignStyle } from '@tldraw/tlschema'
 *
 * // Valid vertical alignment values
 * const topAlign: TLDefaultVerticalAlignStyle = 'start'
 * const centerAlign: TLDefaultVerticalAlignStyle = 'middle'
 * const bottomAlign: TLDefaultVerticalAlignStyle = 'end'
 *
 * // Use in a function parameter
 * function setVerticalAlignment(align: TLDefaultVerticalAlignStyle) {
 *   // Apply vertical alignment to text
 * }
 * ```
 *
 * @public
 */
export declare type TLDefaultVerticalAlignStyle = T.TypeOf<typeof DefaultVerticalAlignStyle>;

/**
 * Document record containing global settings and metadata for a tldraw document.
 * There is exactly one document record per tldraw instance with a fixed ID.
 *
 * @example
 * ```ts
 * const document: TLDocument = {
 *   id: 'document:document',
 *   typeName: 'document',
 *   gridSize: 20,        // Grid snap size in pixels
 *   name: 'My Drawing',  // Document name
 *   meta: {
 *     createdAt: Date.now(),
 *     author: 'user123',
 *     version: '1.0.0'
 *   }
 * }
 *
 * // Update document settings
 * editor.updateDocumentSettings({
 *   name: 'Updated Drawing',
 *   gridSize: 25
 * })
 * ```
 *
 * @public
 */
export declare interface TLDocument extends BaseRecord<'document', RecordId<TLDocument>> {
    /** Grid snap size in pixels. Used for shape positioning and alignment */
    gridSize: number;
    /** Human-readable name of the document */
    name: string;
    /** User-defined metadata for the document */
    meta: JsonObject;
}

/**
 * The fixed ID for the singleton document record in every tldraw store.
 * All document records use this same ID: 'document:document'
 *
 * @example
 * ```ts
 * // Get the document from store
 * const document = store.get(TLDOCUMENT_ID)
 *
 * // Update document settings
 * store.put([{
 *   ...document,
 *   name: 'Updated Name',
 *   gridSize: 25
 * }])
 *
 * // Access via editor
 * const documentSettings = editor.getDocumentSettings()
 * editor.updateDocumentSettings({ name: 'New Name' })
 * ```
 *
 * @public
 */
export declare const TLDOCUMENT_ID: RecordId<TLDocument>;

/**
 * A draw shape represents freehand drawing, sketching, and pen input on the canvas.
 * Draw shapes are composed of segments that can be either smooth curves or straight lines.
 *
 * @public
 * @example
 * ```ts
 * const drawShape: TLDrawShape = {
 *   id: createShapeId(),
 *   typeName: 'shape',
 *   type: 'draw',
 *   x: 50,
 *   y: 50,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:page1',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     color: 'black',
 *     fill: 'none',
 *     dash: 'solid',
 *     size: 'm',
 *     segments: [{
 *       type: 'free',
 *       points: [{ x: 0, y: 0, z: 0.5 }, { x: 20, y: 15, z: 0.6 }]
 *     }],
 *     isComplete: true,
 *     isClosed: false,
 *     isPen: false,
 *     scale: 1
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLDrawShape = TLBaseShape<'draw', TLDrawShapeProps>;

/**
 * Properties for the draw shape, which represents freehand drawing and sketching.
 *
 * @public
 */
export declare interface TLDrawShapeProps {
    /** Color style for the drawing stroke */
    color: TLDefaultColorStyle;
    /** Fill style for closed drawing shapes */
    fill: TLDefaultFillStyle;
    /** Dash pattern style for the stroke */
    dash: TLDefaultDashStyle;
    /** Size/thickness of the drawing stroke */
    size: TLDefaultSizeStyle;
    /** Array of segments that make up the complete drawing path */
    segments: TLDrawShapeSegment[];
    /** Whether the drawing is complete (user finished drawing) */
    isComplete: boolean;
    /** Whether the drawing path forms a closed shape */
    isClosed: boolean;
    /** Whether this drawing was created with a pen/stylus device */
    isPen: boolean;
    /** Scale factor applied to the drawing */
    scale: number;
}

/**
 * A segment of a draw shape representing either freehand drawing or straight line segments.
 *
 * @public
 */
export declare interface TLDrawShapeSegment {
    /** Type of drawing segment - 'free' for freehand curves, 'straight' for line segments */
    type: 'free' | 'straight';
    /** Array of points defining the segment path with x, y coordinates and pressure (z) */
    points: VecModel[];
}

/**
 * An embed shape displays external content like YouTube videos, Figma designs, CodePen demos,
 * and other embeddable content within the tldraw canvas.
 *
 * @public
 * @example
 * ```ts
 * const embedShape: TLEmbedShape = {
 *   id: createShapeId(),
 *   typeName: 'shape',
 *   type: 'embed',
 *   x: 200,
 *   y: 200,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:page1',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     w: 560,
 *     h: 315,
 *     url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLEmbedShape = TLBaseShape<'embed', TLEmbedShapeProps>;

/**
 * Properties for the embed shape, which displays embedded content from external services.
 *
 * @public
 */
export declare interface TLEmbedShapeProps {
    /** Width of the embed shape in pixels */
    w: number;
    /** Height of the embed shape in pixels */
    h: number;
    /** URL of the content to embed (supports YouTube, Figma, CodePen, etc.) */
    url: string;
}

/**
 * A frame shape provides a container for organizing and grouping other shapes.
 * Frames can be used to create sections, organize content, or define specific areas.
 *
 * @public
 * @example
 * ```ts
 * const frameShape: TLFrameShape = {
 *   id: createShapeId(),
 *   typeName: 'shape',
 *   type: 'frame',
 *   x: 0,
 *   y: 0,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:page1',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     w: 400,
 *     h: 300,
 *     name: 'Header Section',
 *     color: 'blue'
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLFrameShape = TLBaseShape<'frame', TLFrameShapeProps>;

/**
 * Properties for the frame shape, which provides a container for organizing other shapes.
 *
 * @public
 */
export declare interface TLFrameShapeProps {
    /** Width of the frame in pixels */
    w: number;
    /** Height of the frame in pixels */
    h: number;
    /** Display name for the frame (shown in UI) */
    name: string;
    /** Color style for the frame border and label */
    color: TLDefaultColorStyle;
}

/**
 * A geo shape represents geometric forms like rectangles, ellipses, triangles, and other
 * predefined shapes. Geo shapes support styling, text content, and can act as containers.
 *
 * @public
 * @example
 * ```ts
 * const geoShape: TLGeoShape = {
 *   id: createShapeId(),
 *   typeName: 'shape',
 *   type: 'geo',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:page1',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     geo: 'rectangle',
 *     w: 200,
 *     h: 100,
 *     color: 'black',
 *     fill: 'solid',
 *     dash: 'solid',
 *     size: 'm',
 *     font: 'draw',
 *     align: 'middle',
 *     verticalAlign: 'middle',
 *     richText: toRichText('Hello World'),
 *     labelColor: 'black',
 *     url: '',
 *     growY: 0,
 *     scale: 1
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLGeoShape = TLBaseShape<'geo', TLGeoShapeProps>;

/**
 * Type representing valid geometric shape styles for geo shapes.
 *
 * @public
 */
export declare type TLGeoShapeGeoStyle = T.TypeOf<typeof GeoShapeGeoStyle>;

/**
 * Properties for the geo shape, which renders various geometric forms with styling and text.
 *
 * @public
 */
export declare interface TLGeoShapeProps {
    /** Geometric shape type (rectangle, ellipse, triangle, etc.) */
    geo: TLGeoShapeGeoStyle;
    /** Dash pattern style for the shape outline */
    dash: TLDefaultDashStyle;
    /** URL link associated with the shape */
    url: string;
    /** Width of the shape in pixels */
    w: number;
    /** Height of the shape in pixels */
    h: number;
    /** Additional vertical growth for text content */
    growY: number;
    /** Scale factor applied to the shape */
    scale: number;
    /** Color style for text label */
    labelColor: TLDefaultColorStyle;
    /** Color style for the shape outline */
    color: TLDefaultColorStyle;
    /** Fill style for the shape interior */
    fill: TLDefaultFillStyle;
    /** Size/thickness style for outline and text */
    size: TLDefaultSizeStyle;
    /** Font style for text content */
    font: TLDefaultFontStyle;
    /** Horizontal alignment for text content */
    align: TLDefaultHorizontalAlignStyle;
    /** Vertical alignment for text content */
    verticalAlign: TLDefaultVerticalAlignStyle;
    /** Rich text content displayed within the shape */
    richText: TLRichText;
}

/**
 * A group shape that acts as a container for organizing multiple shapes into a single logical unit.
 * Groups enable users to move, transform, and manage collections of shapes together while maintaining
 * their relative positions and properties.
 *
 * @public
 * @example
 * ```ts
 * const groupShape: TLGroupShape = {
 *   id: 'shape:group1',
 *   type: 'group',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {},
 *   meta: {},
 *   typeName: 'shape'
 * }
 * ```
 */
export declare type TLGroupShape = TLBaseShape<'group', TLGroupShapeProps>;

/**
 * Properties for a group shape. Group shapes are used to organize and manage collections of shapes as a single unit.
 * Group shapes themselves have no visual properties and serve only as containers.
 *
 * @public
 * @example
 * ```ts
 * const groupProps: TLGroupShapeProps = {}
 * ```
 */
export declare interface TLGroupShapeProps {
}

/**
 * A handle object representing an interactive control point on a shape.
 *
 * Handles allow users to manipulate shape geometry by dragging control points.
 * Each handle has a position, type, and various properties that control its
 * behavior during interactions.
 *
 * @example
 * ```ts
 * // A vertex handle for a line endpoint
 * const lineEndHandle: TLHandle = {
 *   id: 'end',
 *   label: 'End point',
 *   type: 'vertex',
 *   canSnap: true,
 *   index: 'a1',
 *   x: 100,
 *   y: 50
 * }
 *
 * // A virtual handle for adding new points
 * const virtualHandle: TLHandle = {
 *   id: 'virtual-1',
 *   type: 'virtual',
 *   canSnap: false,
 *   index: 'a1V',
 *   x: 75,
 *   y: 25
 * }
 *
 * // A create handle for extending geometry
 * const createHandle: TLHandle = {
 *   id: 'create',
 *   type: 'create',
 *   canSnap: true,
 *   index: 'a2',
 *   x: 200,
 *   y: 100
 * }
 * ```
 *
 * @public
 */
export declare interface TLHandle {
    /** A unique identifier for the handle within the shape */
    id: string;
    /** Optional human-readable label for the handle */
    label?: string;
    /** The type of handle, determining its behavior and interaction mode */
    type: TLHandleType;
    /**
     * @deprecated Use `snapType` instead. Whether this handle should snap to other geometry during interactions.
     */
    canSnap?: boolean;
    /** The type of snap to use for this handle */
    snapType?: 'align' | 'point';
    /** The fractional index used for ordering handles */
    index: IndexKey;
    /** The x-coordinate of the handle in the shape's local coordinate system */
    x: number;
    /** The y-coordinate of the handle in the shape's local coordinate system */
    y: number;
}

/**
 * A union type representing all available handle types.
 *
 * Handle types determine how a handle behaves when interacted with and
 * what kind of shape modification it enables.
 *
 * @example
 * ```ts
 * const vertexHandle: TLHandleType = 'vertex'
 * const virtualHandle: TLHandleType = 'virtual'
 * const createHandle: TLHandleType = 'create'
 * const cloneHandle: TLHandleType = 'clone'
 * ```
 *
 * @public
 */
export declare type TLHandleType = SetValue<typeof TL_HANDLE_TYPES>;

/**
 * A highlight shape representing a highlighting stroke drawn by the user. Highlight shapes
 * are typically semi-transparent and used for marking up or emphasizing content on the canvas.
 *
 * @public
 * @example
 * ```ts
 * const highlightShape: TLHighlightShape = {
 *   id: 'shape:highlight1',
 *   type: 'highlight',
 *   x: 100,
 *   y: 50,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 0.7,
 *   props: {
 *     color: 'yellow',
 *     size: 'l',
 *     segments: [],
 *     isComplete: false,
 *     isPen: false,
 *     scale: 1
 *   },
 *   meta: {},
 *   typeName: 'shape'
 * }
 * ```
 */
export declare type TLHighlightShape = TLBaseShape<'highlight', TLHighlightShapeProps>;

/**
 * Properties for a highlight shape. Highlight shapes represent highlighting strokes made with
 * a highlighting tool, typically used to emphasize or mark up content.
 *
 * @public
 * @example
 * ```ts
 * const highlightProps: TLHighlightShapeProps = {
 *   color: 'yellow',
 *   size: 'm',
 *   segments: [{ type: 'straight', points: [{ x: 0, y: 0, z: 0.5 }] }],
 *   isComplete: true,
 *   isPen: false,
 *   scale: 1
 * }
 * ```
 */
export declare interface TLHighlightShapeProps {
    /** The color style of the highlight stroke */
    color: TLDefaultColorStyle;
    /** The size style determining the thickness of the highlight stroke */
    size: TLDefaultSizeStyle;
    /** Array of segments that make up the highlight stroke path */
    segments: TLDrawShapeSegment[];
    /** Whether the highlight stroke has been completed by the user */
    isComplete: boolean;
    /** Whether the highlight was drawn with a pen/stylus (affects rendering style) */
    isPen: boolean;
    /** Scale factor applied to the highlight shape for display */
    scale: number;
}

/**
 * An asset for images such as PNGs and JPEGs, used by the TLImageShape.
 *
 * @public */
export declare type TLImageAsset = TLBaseAsset<'image', {
    fileSize?: number;
    h: number;
    isAnimated: boolean;
    mimeType: null | string;
    name: string;
    src: null | string;
    w: number;
}>;

/**
 * An image shape representing a raster image on the canvas. Image shapes can display
 * various image formats and support features like cropping, flipping, and asset management.
 *
 * @public
 * @example
 * ```ts
 * const imageShape: TLImageShape = {
 *   id: 'shape:image1',
 *   type: 'image',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     w: 400,
 *     h: 300,
 *     playing: true,
 *     url: '',
 *     assetId: 'asset:photo1',
 *     crop: null,
 *     flipX: false,
 *     flipY: false,
 *     altText: 'Sample photo'
 *   },
 *   meta: {},
 *   typeName: 'shape'
 * }
 * ```
 */
export declare type TLImageShape = TLBaseShape<'image', TLImageShapeProps>;

/**
 * Properties for an image shape. Image shapes display raster images on the canvas,
 * with support for cropping, flipping, and asset management.
 *
 * @public
 * @example
 * ```ts
 * const imageProps: TLImageShapeProps = {
 *   w: 300,
 *   h: 200,
 *   playing: true,
 *   url: 'https://example.com/image.jpg',
 *   assetId: 'asset:image123',
 *   crop: null,
 *   flipX: false,
 *   flipY: false,
 *   altText: 'A sample image'
 * }
 * ```
 */
export declare interface TLImageShapeProps {
    /** Width of the image shape in canvas units */
    w: number;
    /** Height of the image shape in canvas units */
    h: number;
    /** Whether animated images (like GIFs) should play */
    playing: boolean;
    /** URL of the image resource */
    url: string;
    /** ID of the associated asset record, null if no asset */
    assetId: null | TLAssetId;
    /** Crop data defining visible region of the image, null for no cropping */
    crop: null | TLShapeCrop;
    /** Whether to flip the image horizontally */
    flipX: boolean;
    /** Whether to flip the image vertically */
    flipY: boolean;
    /** Alternative text for accessibility and when image fails to load */
    altText: string;
}

/**
 * State that is particular to a single browser tab. The TLInstance record stores
 * all session-specific state including cursor position, selected tools, UI preferences,
 * and temporary interaction state.
 *
 * Each browser tab has exactly one TLInstance record that persists for the duration
 * of the session and tracks the user's current interaction state.
 *
 * @example
 * ```ts
 * const instance: TLInstance = {
 *   id: 'instance:instance',
 *   typeName: 'instance',
 *   currentPageId: 'page:page1',
 *   cursor: { type: 'default', rotation: 0 },
 *   screenBounds: { x: 0, y: 0, w: 1920, h: 1080 },
 *   isFocusMode: false,
 *   isGridMode: true
 * }
 * ```
 *
 * @public
 */
export declare interface TLInstance extends BaseRecord<'instance', TLInstanceId> {
    currentPageId: TLPageId;
    opacityForNextShape: TLOpacityType;
    stylesForNextShape: Record<string, unknown>;
    followingUserId: null | string;
    highlightedUserIds: string[];
    brush: BoxModel | null;
    cursor: TLCursor;
    scribbles: TLScribble[];
    isFocusMode: boolean;
    isDebugMode: boolean;
    isToolLocked: boolean;
    exportBackground: boolean;
    screenBounds: BoxModel;
    insets: boolean[];
    zoomBrush: BoxModel | null;
    chatMessage: string;
    isChatting: boolean;
    isPenMode: boolean;
    isGridMode: boolean;
    isFocused: boolean;
    devicePixelRatio: number;
    /**
     * This is whether the primary input mechanism includes a pointing device of limited accuracy,
     * such as a finger on a touchscreen.
     */
    isCoarsePointer: boolean;
    /**
     * Will be null if the pointer doesn't support hovering (e.g. touch), but true or false
     * otherwise
     */
    isHoveringCanvas: boolean | null;
    openMenus: string[];
    isChangingStyle: boolean;
    isReadonly: boolean;
    meta: JsonObject;
    duplicateProps: {
        offset: {
            x: number;
            y: number;
        };
        shapeIds: TLShapeId[];
    } | null;
}

/**
 * The constant ID used for the singleton TLInstance record.
 *
 * Since each browser tab has exactly one instance, this constant ID
 * is used universally across the application.
 *
 * @example
 * ```ts
 * const instance = store.get(TLINSTANCE_ID)
 * if (instance) {
 *   console.log('Current page:', instance.currentPageId)
 * }
 * ```
 *
 * @public
 */
export declare const TLINSTANCE_ID: TLInstanceId;

/**
 * A unique identifier for TLInstance records.
 *
 * TLInstance IDs are always the constant 'instance:instance' since there
 * is exactly one instance record per browser tab.
 *
 * @public
 */
export declare type TLInstanceId = RecordId<TLInstance>;

/**
 * State that is unique to a particular page within a particular browser tab.
 * This record tracks all page-specific interaction state including selected shapes,
 * editing state, hover state, and other transient UI state that is tied to
 * both a specific page and a specific browser session.
 *
 * Each combination of page and browser tab has its own TLInstancePageState record.
 *
 * @example
 * ```ts
 * const pageState: TLInstancePageState = {
 *   id: 'instance_page_state:page1',
 *   typeName: 'instance_page_state',
 *   pageId: 'page:page1',
 *   selectedShapeIds: ['shape:rect1', 'shape:circle2'],
 *   hoveredShapeId: 'shape:text3',
 *   editingShapeId: null,
 *   focusedGroupId: null
 * }
 * ```
 *
 * @public
 */
export declare interface TLInstancePageState extends BaseRecord<'instance_page_state', TLInstancePageStateId> {
    pageId: RecordId<TLPage>;
    selectedShapeIds: TLShapeId[];
    hintingShapeIds: TLShapeId[];
    erasingShapeIds: TLShapeId[];
    hoveredShapeId: null | TLShapeId;
    editingShapeId: null | TLShapeId;
    croppingShapeId: null | TLShapeId;
    focusedGroupId: null | TLShapeId;
    meta: JsonObject;
}

/**
 * A unique identifier for TLInstancePageState records.
 *
 * Instance page state IDs follow the format 'instance_page_state:' followed
 * by a unique identifier, typically related to the page ID.
 *
 * @example
 * ```ts
 * const stateId: TLInstancePageStateId = 'instance_page_state:page1'
 * ```
 *
 * @public
 */
export declare type TLInstancePageStateId = RecordId<TLInstancePageState>;

/**
 * Represents the presence state of a user in a collaborative tldraw session.
 * This record tracks what another user is doing: their cursor position, selected
 * shapes, current page, and other real-time activity indicators.
 *
 * Instance presence records are used in multiplayer environments to show
 * where other collaborators are working and what they're doing.
 *
 * @example
 * ```ts
 * const presence: TLInstancePresence = {
 *   id: 'instance_presence:user123',
 *   typeName: 'instance_presence',
 *   userId: 'user123',
 *   userName: 'Alice',
 *   color: '#FF6B6B',
 *   cursor: { x: 100, y: 150, type: 'default', rotation: 0 },
 *   currentPageId: 'page:main',
 *   selectedShapeIds: ['shape:rect1']
 * }
 * ```
 *
 * @public
 */
export declare interface TLInstancePresence extends BaseRecord<'instance_presence', TLInstancePresenceID> {
    userId: string;
    userName: string;
    lastActivityTimestamp: null | number;
    color: string;
    camera: {
        x: number;
        y: number;
        z: number;
    } | null;
    selectedShapeIds: TLShapeId[];
    currentPageId: TLPageId;
    brush: BoxModel | null;
    scribbles: TLScribble[];
    screenBounds: BoxModel | null;
    followingUserId: null | string;
    cursor: {
        rotation: number;
        type: TLCursor['type'];
        x: number;
        y: number;
    } | null;
    chatMessage: string;
    meta: JsonObject;
}

/**
 * A unique identifier for TLInstancePresence records.
 *
 * Instance presence IDs follow the format 'instance_presence:' followed
 * by a unique identifier, typically the user ID.
 *
 * @example
 * ```ts
 * const presenceId: TLInstancePresenceID = 'instance_presence:user123'
 * ```
 *
 * @public
 */
export declare type TLInstancePresenceID = RecordId<TLInstancePresence>;

/**
 * A language definition object representing a supported localization in tldraw.
 *
 * Derived from the LANGUAGES array, this type represents a single language entry
 * containing a locale identifier and human-readable label. The locale follows
 * BCP 47 standards (e.g., 'en', 'fr', 'zh-CN') and the label is in the native language.
 *
 * @example
 * ```ts
 * import { TLLanguage } from '@tldraw/tlschema'
 *
 * // Using TLLanguage type
 * const currentLanguage: TLLanguage = { locale: 'fr', label: 'Français' }
 *
 * // Access locale and label
 * console.log(currentLanguage.locale) // "fr"
 * console.log(currentLanguage.label)  // "Français"
 * ```
 *
 * @public
 */
export declare type TLLanguage = (typeof LANGUAGES)[number];

/**
 * A line shape that represents a multi-point line or spline on the canvas. Line shapes
 * allow users to draw connected paths with multiple points, supporting both straight
 * line segments and smooth curved splines.
 *
 * @public
 * @example
 * ```ts
 * const lineShape: TLLineShape = {
 *   id: 'shape:line1',
 *   type: 'line',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     color: 'red',
 *     dash: 'dashed',
 *     size: 'l',
 *     spline: 'cubic',
 *     points: {
 *       'start': { id: 'start', index: 'a1', x: 0, y: 0 },
 *       'end': { id: 'end', index: 'a2', x: 200, y: 100 }
 *     },
 *     scale: 1
 *   },
 *   meta: {},
 *   typeName: 'shape'
 * }
 * ```
 */
export declare type TLLineShape = TLBaseShape<'line', TLLineShapeProps>;

/**
 * Represents a single point in a line shape. Line shapes are made up of multiple points
 * that define the path of the line, with each point having coordinates and ordering information.
 *
 * @public
 * @example
 * ```ts
 * const linePoint: TLLineShapePoint = {
 *   id: 'a1',
 *   index: 'a1' as IndexKey,
 *   x: 100,
 *   y: 50
 * }
 * ```
 */
export declare interface TLLineShapePoint {
    /** Unique identifier for this point, used for tracking and ordering */
    id: string;
    /** Fractional index key used for ordering points along the line */
    index: IndexKey;
    /** X coordinate of the point relative to the line shape's origin */
    x: number;
    /** Y coordinate of the point relative to the line shape's origin */
    y: number;
}

/**
 * Properties for a line shape. Line shapes represent multi-point lines or splines
 * that can be drawn by connecting multiple points with either straight segments or curves.
 *
 * @public
 * @example
 * ```ts
 * const lineProps: TLLineShapeProps = {
 *   color: 'black',
 *   dash: 'solid',
 *   size: 'm',
 *   spline: 'line',
 *   points: {
 *     'a1': { id: 'a1', index: 'a1', x: 0, y: 0 },
 *     'a2': { id: 'a2', index: 'a2', x: 100, y: 50 }
 *   },
 *   scale: 1
 * }
 * ```
 */
export declare interface TLLineShapeProps {
    /** Color style of the line stroke */
    color: TLDefaultColorStyle;
    /** Dash pattern style for the line (solid, dashed, dotted) */
    dash: TLDefaultDashStyle;
    /** Size/thickness style of the line stroke */
    size: TLDefaultSizeStyle;
    /** Interpolation style between points (straight lines or curved splines) */
    spline: TLLineShapeSplineStyle;
    /** Dictionary of points that make up the line, keyed by point ID */
    points: Record<string, TLLineShapePoint>;
    /** Scale factor applied to the line shape for display */
    scale: number;
}

/**
 * Type representing the spline style options for line shapes.
 * - 'line': Straight line segments between points
 * - 'cubic': Smooth cubic bezier curves between points
 *
 * @public
 */
export declare type TLLineShapeSplineStyle = T.TypeOf<typeof LineShapeSplineStyle>;

/**
 * A note shape representing a sticky note or text annotation on the canvas.
 * Note shapes support rich text formatting, various styling options, and can
 * be used for annotations, reminders, or general text content.
 *
 * @public
 * @example
 * ```ts
 * const noteShape: TLNoteShape = {
 *   id: 'shape:note1',
 *   type: 'note',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     color: 'light-blue',
 *     labelColor: 'black',
 *     size: 's',
 *     font: 'sans',
 *     fontSizeAdjustment: 2,
 *     align: 'start',
 *     verticalAlign: 'start',
 *     growY: 50,
 *     url: 'https://example.com',
 *     richText: toRichText('Important **note**!'),
 *     scale: 1
 *   },
 *   meta: {},
 *   typeName: 'shape'
 * }
 * ```
 */
export declare type TLNoteShape = TLBaseShape<'note', TLNoteShapeProps>;

/**
 * Properties for a note shape. Note shapes represent sticky notes or text annotations
 * with rich formatting capabilities and various styling options.
 *
 * @public
 * @example
 * ```ts
 * const noteProps: TLNoteShapeProps = {
 *   color: 'yellow',
 *   labelColor: 'black',
 *   size: 'm',
 *   font: 'draw',
 *   fontSizeAdjustment: 0,
 *   align: 'middle',
 *   verticalAlign: 'middle',
 *   growY: 0,
 *   url: '',
 *   richText: toRichText('Hello **world**!'),
 *   scale: 1
 * }
 * ```
 */
export declare interface TLNoteShapeProps {
    /** Background color style of the note */
    color: TLDefaultColorStyle;
    /** Text color style for the note content */
    labelColor: TLDefaultColorStyle;
    /** Size style determining the font size and note dimensions */
    size: TLDefaultSizeStyle;
    /** Font family style for the note text */
    font: TLDefaultFontStyle;
    /** Adjustment to the base font size (positive increases, negative decreases) */
    fontSizeAdjustment: number;
    /** Horizontal alignment of text within the note */
    align: TLDefaultHorizontalAlignStyle;
    /** Vertical alignment of text within the note */
    verticalAlign: TLDefaultVerticalAlignStyle;
    /** Additional height growth for the note beyond its base size */
    growY: number;
    /** Optional URL associated with the note for linking */
    url: string;
    /** Rich text content with formatting like bold, italic, etc. */
    richText: TLRichText;
    /** Scale factor applied to the note shape for display */
    scale: number;
}

/**
 * A type representing opacity values in tldraw.
 *
 * Opacity values are numbers between 0 and 1, where 0 is fully transparent
 * and 1 is fully opaque. This type is used throughout the editor to control
 * the transparency of shapes, UI elements, and other visual components.
 *
 * @example
 * ```ts
 * const fullyOpaque: TLOpacityType = 1.0
 * const halfTransparent: TLOpacityType = 0.5
 * const fullyTransparent: TLOpacityType = 0.0
 * const quarterOpaque: TLOpacityType = 0.25
 * ```
 *
 * @public
 */
export declare type TLOpacityType = number;

/**
 * A page within a tldraw document. Pages are containers for shapes and provide
 * a way to organize content into separate canvases. Each document can have multiple
 * pages, and users can navigate between them.
 *
 * Pages have a name for identification, an index for ordering, and can store
 * custom metadata.
 *
 * @example
 * ```ts
 * const page: TLPage = {
 *   id: 'page:page1',
 *   typeName: 'page',
 *   name: 'Page 1',
 *   index: 'a1',
 *   meta: { description: 'Main design page' }
 * }
 * ```
 *
 * @public
 */
export declare interface TLPage extends BaseRecord<'page', TLPageId> {
    name: string;
    index: IndexKey;
    meta: JsonObject;
}

/**
 * A unique identifier for TLPage records.
 *
 * Page IDs follow the format 'page:' followed by a unique string identifier.
 *
 * @example
 * ```ts
 * const pageId: TLPageId = 'page:main'
 * const pageId2: TLPageId = createShapeId() // generates 'page:abc123'
 * ```
 *
 * @public
 */
export declare type TLPageId = RecordId<TLPage>;

/**
 * The ID of a shape's parent, which can be either a page or another shape.
 *
 * Shapes can be parented to pages (for top-level shapes) or to other shapes
 * (for shapes inside frames or groups).
 *
 * @example
 * ```ts
 * // Shape parented to a page
 * const pageParentId: TLParentId = 'page:main'
 *
 * // Shape parented to another shape (e.g., inside a frame)
 * const shapeParentId: TLParentId = 'shape:frame123'
 * ```
 *
 * @public
 */
export declare type TLParentId = TLPageId | TLShapeId;

/**
 * Represents the current pointer/cursor position and activity state.
 * This record tracks the mouse or touch pointer coordinates and when
 * the pointer was last active, useful for cursor synchronization in
 * collaborative environments.
 *
 * There is typically one pointer record per browser tab that gets updated
 * as the user moves their mouse or touches the screen.
 *
 * @example
 * ```ts
 * const pointer: TLPointer = {
 *   id: 'pointer:pointer',
 *   typeName: 'pointer',
 *   x: 150,
 *   y: 200,
 *   lastActivityTimestamp: Date.now(),
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare interface TLPointer extends BaseRecord<'pointer', TLPointerId> {
    x: number;
    y: number;
    lastActivityTimestamp: number;
    meta: JsonObject;
}

/**
 * The constant ID used for the singleton TLPointer record.
 *
 * Since each browser tab typically has one pointer, this constant ID
 * is used universally across the application.
 *
 * @example
 * ```ts
 * const pointer = store.get(TLPOINTER_ID)
 * if (pointer) {
 *   console.log('Pointer at:', pointer.x, pointer.y)
 * }
 * ```
 *
 * @public
 */
export declare const TLPOINTER_ID: TLPointerId;

/**
 * A unique identifier for TLPointer records.
 *
 * Pointer IDs follow the format 'pointer:' followed by a unique identifier.
 * Typically there is one pointer record with a constant ID per session.
 *
 * @example
 * ```ts
 * const pointerId: TLPointerId = 'pointer:pointer'
 * ```
 *
 * @public
 */
export declare type TLPointerId = RecordId<TLPointer>;

/**
 * The shape of data used to create a presence record.
 *
 * This type represents all the properties needed to construct a TLInstancePresence record.
 * It includes user information, cursor state, camera position, selected shapes, and other
 * presence-related data that gets synchronized across multiplayer clients.
 *
 * @public
 */
export declare type TLPresenceStateInfo = Parameters<(typeof InstancePresenceRecordType)['create']>[0];

/**
 * The information about a user which is used for multiplayer features.
 * @public
 */
export declare interface TLPresenceUserInfo {
    /**
     * id - A unique identifier for the user. This should be the same across all devices and sessions.
     */
    id: string;
    /**
     * The user's display name.
     */
    name?: null | string;
    /**
     * The user's color. If not given, a random color will be assigned.
     */
    color?: null | string;
}

/**
 * A migration definition for shape or record properties.
 *
 * Defines how to transform record properties when migrating between schema versions.
 * Each migration has an `up` function to upgrade data and an optional `down` function
 * to downgrade data if needed.
 *
 * @example
 * ```ts
 * const addColorMigration: TLPropsMigration = {
 *   id: 'com.myapp.shape.custom/1.0.0',
 *   up: (props) => {
 *     // Add a default color property
 *     return { ...props, color: 'black' }
 *   },
 *   down: (props) => {
 *     // Remove the color property
 *     const { color, ...rest } = props
 *     return rest
 *   }
 * }
 * ```
 *
 * @public
 */
export declare interface TLPropsMigration {
    readonly id: MigrationId;
    readonly dependsOn?: MigrationId[];
    readonly up: (props: any) => any;
    /**
     * If a down migration was deployed more than a couple of months ago it should be safe to retire it.
     * We only really need them to smooth over the transition between versions, and some folks do keep
     * browser tabs open for months without refreshing, but at a certain point that kind of behavior is
     * on them. Plus anyway recently chrome has started to actually kill tabs that are open for too long
     * rather than just suspending them, so if other browsers follow suit maybe it's less of a concern.
     *
     * @public
     */
    readonly down?: 'none' | 'retired' | ((props: any) => any);
}

/**
 * A sequence of property migrations for a record type.
 *
 * Contains an ordered array of migrations that should be applied to transform
 * record properties from one version to another. Migrations can include both
 * property-specific migrations and standalone dependency declarations.
 *
 * @example
 * ```ts
 * const myShapeMigrations: TLPropsMigrations = {
 *   sequence: [
 *     {
 *       id: 'com.myapp.shape.custom/1.0.0',
 *       up: (props) => ({ ...props, version: 1 })
 *     },
 *     {
 *       id: 'com.myapp.shape.custom/2.0.0',
 *       up: (props) => ({ ...props, newFeature: true })
 *     }
 *   ]
 * }
 * ```
 *
 * @public
 */
export declare interface TLPropsMigrations {
    readonly sequence: Array<StandaloneDependsOn | TLPropsMigration>;
}

/**
 * Union type representing all possible record types in a tldraw store.
 * This includes both persistent records (documents, pages, shapes, assets, bindings)
 * and session/presence records (cameras, instances, pointers, page states).
 *
 * Records are organized by scope:
 * - **document**: Persisted across sessions (shapes, pages, assets, bindings, documents)
 * - **session**: Local to current session (cameras, instances, page states)
 * - **presence**: Ephemeral user presence data (pointers, instance presence)
 *
 * @example
 * ```ts
 * // Function that works with any record type
 * function processRecord(record: TLRecord) {
 *   switch (record.typeName) {
 *     case 'shape':
 *       console.log(`Shape: ${record.type} at (${record.x}, ${record.y})`)
 *       break
 *     case 'page':
 *       console.log(`Page: ${record.name}`)
 *       break
 *     case 'asset':
 *       console.log(`Asset: ${record.type}`)
 *       break
 *     case 'camera':
 *       console.log(`Camera at (${record.x}, ${record.y}) zoom: ${record.z}`)
 *       break
 *     // ... handle other record types
 *   }
 * }
 *
 * // Get all records from store
 * const allRecords: TLRecord[] = store.allRecords()
 *
 * // Filter by record type using type guards
 * import { isShape, isPage, isAsset } from '@tldraw/tlschema'
 * const shapes = allRecords.filter(isShape)
 * const pages = allRecords.filter(isPage)
 * const assets = allRecords.filter(isAsset)
 * ```
 *
 * @public
 */
export declare type TLRecord = TLAsset | TLBinding | TLCamera | TLDocument | TLInstance | TLInstancePageState | TLInstancePresence | TLPage | TLPointer | TLShape;

/**
 * Type representing rich text content in tldraw. Rich text follows a document-based
 * structure with a root document containing an array of content blocks (paragraphs,
 * text nodes, etc.). This enables formatted text with support for multiple paragraphs,
 * styling, and other rich content.
 *
 * @public
 * @example
 * ```ts
 * const richText: TLRichText = {
 *   type: 'doc',
 *   content: [
 *     {
 *       type: 'paragraph',
 *       content: [{ type: 'text', text: 'Hello world!' }]
 *     }
 *   ]
 * }
 * ```
 */
export declare type TLRichText = T.TypeOf<typeof richTextValidator>;

/**
 * The complete schema definition for a tldraw store, encompassing all record types,
 * validation rules, and migration sequences. This schema defines the structure of
 * the persistent data model used by tldraw.
 *
 * @public
 * @example
 * ```ts
 * import { createTLSchema, defaultShapeSchemas } from '@tldraw/tlschema'
 * import { Store } from '@tldraw/store'
 *
 * const schema: TLSchema = createTLSchema({
 *   shapes: defaultShapeSchemas,
 * })
 *
 * const store = new Store({ schema })
 * ```
 */
export declare type TLSchema = StoreSchema<TLRecord, TLStoreProps>;

/**
 * A scribble object representing a drawing stroke in tldraw.
 *
 * Scribbles are temporary drawing strokes that appear during freehand drawing
 * operations. They provide visual feedback as the user draws and can be styled
 * with various properties like size, color, and effects.
 *
 * @example
 * ```ts
 * // A basic scribble stroke
 * const scribble: TLScribble = {
 *   id: 'scribble-123',
 *   points: [
 *     { x: 0, y: 0, z: 0.5 },
 *     { x: 10, y: 5, z: 0.7 },
 *     { x: 20, y: 10, z: 0.6 }
 *   ],
 *   size: 4,
 *   color: 'black',
 *   opacity: 0.8,
 *   state: 'active',
 *   delay: 0,
 *   shrink: 0.1,
 *   taper: true
 * }
 *
 * // A laser pointer scribble
 * const laserScribble: TLScribble = {
 *   id: 'laser-pointer',
 *   points: [{ x: 50, y: 50, z: 1.0 }],
 *   size: 8,
 *   color: 'laser',
 *   opacity: 1.0,
 *   state: 'active',
 *   delay: 100,
 *   shrink: 0,
 *   taper: false
 * }
 * ```
 *
 * @public
 */
export declare interface TLScribble {
    /** Unique identifier for the scribble */
    id: string;
    /** Array of points that make up the scribble path */
    points: VecModel[];
    /** The brush size/width of the scribble stroke */
    size: number;
    /** The color of the scribble using canvas UI color types */
    color: TLCanvasUiColor;
    /** The opacity of the scribble (0-1) */
    opacity: number;
    /** The current state of the scribble drawing */
    state: SetValue<typeof TL_SCRIBBLE_STATES>;
    /** Time delay in milliseconds for animation effects */
    delay: number;
    /** Amount the stroke should shrink over time (0-1) */
    shrink: number;
    /** Whether the stroke should taper at the ends */
    taper: boolean;
}

/**
 * A serialized representation of a tldraw store that can be persisted or transmitted.
 * Contains all store records in a JSON-serializable format.
 *
 * @public
 * @example
 * ```ts
 * // Serialize a store
 * const serializedStore: TLSerializedStore = store.serialize()
 *
 * // Save to localStorage
 * localStorage.setItem('drawing', JSON.stringify(serializedStore))
 * ```
 */
export declare type TLSerializedStore = SerializedStore<TLRecord>;

/**
 * The set of all shapes that are available in the editor, including unknown shapes.
 *
 * This is the primary shape type used throughout tldraw. It includes both the
 * built-in default shapes and any custom shapes that might be added.
 *
 * @example
 * ```ts
 * // Work with any shape in the editor
 * function moveShape(shape: TLShape, deltaX: number, deltaY: number): TLShape {
 *   return {
 *     ...shape,
 *     x: shape.x + deltaX,
 *     y: shape.y + deltaY
 *   }
 * }
 * ```
 *
 * @public
 */
export declare type TLShape = TLDefaultShape | TLUnknownShape;

/**
 * Defines cropping parameters for shapes that support cropping.
 *
 * Specifies the visible area of an asset (like an image or video) within a shape.
 * The crop is defined by top-left and bottom-right coordinates in normalized space (0-1),
 * where (0,0) is the top-left of the original asset and (1,1) is the bottom-right.
 *
 * @example
 * ```ts
 * // Crop the center 50% of an image
 * const centerCrop: TLShapeCrop = {
 *   topLeft: { x: 0.25, y: 0.25 },
 *   bottomRight: { x: 0.75, y: 0.75 }
 * }
 *
 * // Crop for a circular image shape
 * const circleCrop: TLShapeCrop = {
 *   topLeft: { x: 0, y: 0 },
 *   bottomRight: { x: 1, y: 1 },
 *   isCircle: true
 * }
 * ```
 *
 * @public
 */
export declare interface TLShapeCrop {
    topLeft: VecModel;
    bottomRight: VecModel;
    isCircle?: boolean;
}

/**
 * A unique identifier for a shape record.
 *
 * Shape IDs are branded strings that start with "shape:" followed by a unique identifier.
 * This type-safe approach prevents mixing up different types of record IDs.
 *
 * @example
 * ```ts
 * const shapeId: TLShapeId = createShapeId() // "shape:abc123"
 * const customId: TLShapeId = createShapeId('my-custom-id') // "shape:my-custom-id"
 * ```
 *
 * @public
 */
export declare type TLShapeId = RecordId<TLUnknownShape>;

/**
 * A partial version of a shape, useful for updates and patches.
 *
 * This type represents a shape where all properties except `id` and `type` are optional.
 * It's commonly used when updating existing shapes or creating shape patches.
 *
 * @example
 * ```ts
 * // Update a shape's position
 * const shapeUpdate: TLShapePartial = {
 *   id: 'shape:123',
 *   type: 'geo',
 *   x: 100,
 *   y: 200
 * }
 *
 * // Update shape properties
 * const propsUpdate: TLShapePartial<TLGeoShape> = {
 *   id: 'shape:123',
 *   type: 'geo',
 *   props: {
 *     w: 150,
 *     h: 100
 *   }
 * }
 * ```
 *
 * @public
 */
export declare type TLShapePartial<T extends TLShape = TLShape> = T extends T ? {
    id: TLShapeId;
    meta?: Partial<T['meta']>;
    props?: Partial<T['props']>;
    type: T['type'];
} & Partial<Omit<T, 'id' | 'meta' | 'props' | 'type'>> : never;

/**
 * The main tldraw store type, representing a reactive database of tldraw records
 * with associated store properties. This is the central data structure that holds
 * all shapes, assets, pages, and user state.
 *
 * @public
 * @example
 * ```ts
 * import { Store } from '@tldraw/store'
 * import { createTLSchema } from '@tldraw/tlschema'
 *
 * const schema = createTLSchema()
 * const store: TLStore = new Store({
 *   schema,
 *   props: {
 *     defaultName: 'Untitled',
 *     assets: myAssetStore,
 *     onMount: () => console.log('Store mounted')
 *   }
 * })
 * ```
 */
export declare type TLStore = Store<TLRecord, TLStoreProps>;

/**
 * Configuration properties for a tldraw store, defining its behavior and integrations.
 * These props are passed when creating a new store instance.
 *
 * @public
 * @example
 * ```ts
 * const storeProps: TLStoreProps = {
 *   defaultName: 'My Drawing',
 *   assets: myAssetStore,
 *   onMount: (editor) => {
 *     console.log('Editor mounted')
 *     return () => console.log('Editor unmounted')
 *   },
 *   collaboration: {
 *     status: statusSignal,
 *     mode: modeSignal
 *   }
 * }
 *
 * const store = new Store({ schema, props: storeProps })
 * ```
 */
export declare interface TLStoreProps {
    /** Default name for new documents created in this store */
    defaultName: string;
    /** Asset store implementation for handling file uploads and storage */
    assets: Required<TLAssetStore>;
    /**
     * Called when an {@link @tldraw/editor#Editor} connected to this store is mounted.
     * Can optionally return a cleanup function that will be called when unmounted.
     *
     * @param editor - The editor instance that was mounted
     * @returns Optional cleanup function
     */
    onMount(editor: unknown): (() => void) | void;
    /** Optional collaboration configuration for multiplayer features */
    collaboration?: {
        /** Signal indicating collaboration mode permissions */
        mode?: null | Signal<'readonly' | 'readwrite'>;
        /** Signal indicating online/offline collaboration status */
        status: null | Signal<'offline' | 'online'>;
    };
}

/**
 * The complete schema type for a tldraw store, defining the structure and validation rules
 * for all tldraw records and store properties.
 *
 * @public
 * @example
 * ```ts
 * import { createTLSchema } from '@tldraw/tlschema'
 *
 * const schema = createTLSchema()
 * const storeSchema: TLStoreSchema = schema
 * ```
 */
export declare type TLStoreSchema = StoreSchema<TLRecord, TLStoreProps>;

/**
 * A snapshot of a tldraw store at a specific point in time, containing all records
 * and metadata. Used for persistence, synchronization, and creating store backups.
 *
 * @public
 * @example
 * ```ts
 * // Create a snapshot
 * const snapshot: TLStoreSnapshot = store.getSnapshot()
 *
 * // Restore from snapshot
 * store.loadSnapshot(snapshot)
 * ```
 */
export declare type TLStoreSnapshot = StoreSnapshot<TLRecord>;

/**
 * A text shape that can display formatted text content with various styling options.
 * Text shapes support rich formatting, automatic sizing, and consistent styling through
 * the tldraw style system.
 *
 * @public
 * @example
 * ```ts
 * const textShape: TLTextShape = {
 *   id: 'shape:text123',
 *   typeName: 'shape',
 *   type: 'text',
 *   x: 100,
 *   y: 200,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     color: 'black',
 *     size: 'm',
 *     font: 'draw',
 *     textAlign: 'start',
 *     w: 200,
 *     richText: toRichText('Sample text'),
 *     scale: 1,
 *     autoSize: false
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLTextShape = TLBaseShape<'text', TLTextShapeProps>;

/**
 * Configuration interface defining properties for text shapes in tldraw.
 * Text shapes support rich formatting, styling, and automatic sizing.
 *
 * @public
 * @example
 * ```ts
 * const textProps: TLTextShapeProps = {
 *   color: 'black',
 *   size: 'm',
 *   font: 'draw',
 *   textAlign: 'start',
 *   w: 200,
 *   richText: toRichText('Hello **bold** text'),
 *   scale: 1,
 *   autoSize: true
 * }
 * ```
 */
export declare interface TLTextShapeProps {
    color: TLDefaultColorStyle;
    size: TLDefaultSizeStyle;
    font: TLDefaultFontStyle;
    textAlign: TLDefaultTextAlignStyle;
    w: number;
    richText: TLRichText;
    scale: number;
    autoSize: boolean;
}

/**
 * A type for a binding that is available in the editor but whose type is
 * unknown—either one of the editor's default bindings or else a custom binding.
 * Used internally for type-safe handling of bindings with unknown structure.
 *
 * @example
 * ```ts
 * // Function that works with any binding type
 * function processBinding(binding: TLUnknownBinding) {
 *   console.log(`Processing ${binding.type} binding from ${binding.fromId} to ${binding.toId}`)
 *   // Handle binding properties generically
 * }
 * ```
 *
 * @public
 */
export declare type TLUnknownBinding = TLBaseBinding<string, object>;

/**
 * A type for a shape that is available in the editor but whose type is
 * unknown—either one of the editor's default shapes or else a custom shape.
 *
 * This is useful when working with shapes generically without knowing their specific type.
 * The shape type is a string and props are a generic object.
 *
 * @example
 * ```ts
 * // Handle any shape regardless of its specific type
 * function processUnknownShape(shape: TLUnknownShape) {
 *   console.log(`Processing shape of type: ${shape.type}`)
 *   console.log(`Position: (${shape.x}, ${shape.y})`)
 * }
 * ```
 *
 * @public
 */
export declare type TLUnknownShape = TLBaseShape<string, object>;

/**
 * An asset record representing video files that can be displayed in video shapes.
 * Video assets store metadata about video files including dimensions, MIME type,
 * animation status, and file source information. They are referenced by TLVideoShape
 * instances to display video content on the canvas.
 *
 * @example
 * ```ts
 * import { TLVideoAsset } from '@tldraw/tlschema'
 *
 * const videoAsset: TLVideoAsset = {
 *   id: 'asset:video123',
 *   typeName: 'asset',
 *   type: 'video',
 *   props: {
 *     w: 1920,
 *     h: 1080,
 *     name: 'my-video.mp4',
 *     isAnimated: true,
 *     mimeType: 'video/mp4',
 *     src: 'https://example.com/video.mp4',
 *     fileSize: 5242880
 *   },
 *   meta: {}
 * }
 * ```
 *
 * @public
 */
export declare type TLVideoAsset = TLBaseAsset<'video', {
    /** The file size in bytes, optional for backward compatibility */
    fileSize?: number;
    /** The height of the video in pixels */
    h: number;
    /** The MIME type of the video file (e.g., 'video/mp4', 'video/webm'), null if unknown */
    mimeType: null | string;
    /** The original filename or display name of the video */
    name: string;
    /** The source URL or data URI for the video file, null if not yet available */
    src: null | string;
    /** The width of the video in pixels */
    w: number;
    /** Whether the video contains animation/motion (true for most videos) */
    isAnimated: boolean;
}>;

/**
 * A video shape that can display video content with playback controls and timing.
 * Video shapes support both direct URL references and asset-based video storage,
 * with accessibility features and playback state management.
 *
 * @public
 * @example
 * ```ts
 * const videoShape: TLVideoShape = {
 *   id: 'shape:video123',
 *   typeName: 'shape',
 *   type: 'video',
 *   x: 100,
 *   y: 100,
 *   rotation: 0,
 *   index: 'a1',
 *   parentId: 'page:main',
 *   isLocked: false,
 *   opacity: 1,
 *   props: {
 *     w: 640,
 *     h: 480,
 *     time: 15.5,
 *     playing: false,
 *     autoplay: false,
 *     url: 'https://example.com/video.mp4',
 *     assetId: 'asset:video123',
 *     altText: 'Product demo video'
 *   },
 *   meta: {}
 * }
 * ```
 */
export declare type TLVideoShape = TLBaseShape<'video', TLVideoShapeProps>;

/**
 * Configuration interface defining properties for video shapes in tldraw.
 * Video shapes can display video content from URLs or asset references,
 * with controls for playback state, timing, and accessibility.
 *
 * @public
 * @example
 * ```ts
 * const videoProps: TLVideoShapeProps = {
 *   w: 640,
 *   h: 480,
 *   time: 0,
 *   playing: false,
 *   autoplay: true,
 *   url: 'https://example.com/video.mp4',
 *   assetId: 'asset:video123',
 *   altText: 'Educational video about shapes'
 * }
 * ```
 */
export declare interface TLVideoShapeProps {
    w: number;
    h: number;
    time: number;
    playing: boolean;
    autoplay: boolean;
    url: string;
    assetId: null | TLAssetId;
    altText: string;
}

/**
 * Converts a plain text string into a TLRichText object. Each line of the input
 * text becomes a separate paragraph in the rich text document. Empty lines are
 * preserved as empty paragraphs to maintain the original text structure.
 *
 * @param text - The plain text string to convert to rich text
 * @returns A TLRichText object with the text content structured as paragraphs
 * @public
 * @example
 * ```ts
 * const richText = toRichText('Hello\nWorld')
 * // Returns:
 * // {
 * //   type: 'doc',
 * //   content: [
 * //     { type: 'paragraph', content: [{ type: 'text', text: 'Hello' }] },
 * //     { type: 'paragraph', content: [{ type: 'text', text: 'World' }] }
 * //   ]
 * // }
 *
 * const emptyLine = toRichText('Line 1\n\nLine 3')
 * // Creates three paragraphs, with the middle one being empty
 * ```
 */
export declare function toRichText(text: string): TLRichText;

/**
 * A serializable model for 2D vectors.
 *
 * @public */
export declare interface VecModel {
    x: number;
    y: number;
    z?: number;
}

/**
 * Validator for VecModel objects that ensures they have numeric x and y coordinates,
 * with an optional z coordinate for 3D vectors. Used throughout the schema to
 * validate point and vector data structures.
 *
 * @public
 * @example
 * ```ts
 * const vector2D = { x: 10, y: 20 }
 * const isValid = vecModelValidator.check(vector2D) // true
 *
 * const vector3D = { x: 10, y: 20, z: 30 }
 * const isValid3D = vecModelValidator.check(vector3D) // true
 * ```
 */
export declare const vecModelValidator: T.ObjectValidator<VecModel>;

/**
 * Migration sequence for video shape schema evolution. This handles transforming
 * video shape data between different versions as the schema evolves over time.
 *
 * Key migrations include:
 * - AddUrlProp: Added URL property for direct video links
 * - MakeUrlsValid: Ensured all URLs conform to link URL validation
 * - AddAltText: Added accessibility support with alternative text
 * - AddAutoplay: Added autoplay control for video playback
 *
 * @public
 */
export declare const videoShapeMigrations: TLPropsMigrations;

/**
 * Validation schema for video shape properties. This defines the runtime validation
 * rules that ensure video shape data integrity, including URL validation, numeric
 * constraints, and proper asset ID formatting.
 *
 * @public
 * @example
 * ```ts
 * import { videoShapeProps } from '@tldraw/tlschema'
 *
 * // Validate video URL
 * const isValidUrl = videoShapeProps.url.isValid('https://example.com/video.mp4')
 * const isValidTime = videoShapeProps.time.isValid(42.5)
 *
 * if (isValidUrl && isValidTime) {
 *   // Video properties are valid
 * }
 * ```
 */
export declare const videoShapeProps: RecordProps<TLVideoShape>;

export { }
