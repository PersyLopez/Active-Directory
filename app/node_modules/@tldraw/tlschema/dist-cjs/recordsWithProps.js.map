{
  "version": 3,
  "sources": ["../src/recordsWithProps.ts"],
  "sourcesContent": ["import {\n\tMigration,\n\tMigrationId,\n\tMigrationSequence,\n\tRecordType,\n\tStandaloneDependsOn,\n\tUnknownRecord,\n\tcreateMigrationSequence,\n} from '@tldraw/store'\nimport { MakeUndefinedOptional, assert } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { SchemaPropsInfo } from './createTLSchema'\n\n/**\n * Maps a record's property types to their corresponding validators.\n *\n * This utility type takes a record type with a `props` object and creates\n * a mapping where each property key maps to a validator for that property's type.\n * This is used to define validation schemas for record properties.\n *\n * @example\n * ```ts\n * interface MyShape extends TLBaseShape<'custom', { width: number; color: string }> {}\n *\n * // Define validators for the shape properties\n * const myShapeProps: RecordProps<MyShape> = {\n *   width: T.number,\n *   color: T.string\n * }\n * ```\n *\n * @public\n */\nexport type RecordProps<R extends UnknownRecord & { props: object }> = {\n\t[K in keyof R['props']]: T.Validatable<R['props'][K]>\n}\n\n/**\n * Extracts the TypeScript types from a record properties configuration.\n *\n * Takes a configuration object where values are validators and returns the\n * corresponding TypeScript types, with undefined values made optional.\n *\n * @example\n * ```ts\n * const shapePropsConfig = {\n *   width: T.number,\n *   height: T.number,\n *   color: T.optional(T.string)\n * }\n *\n * type ShapeProps = RecordPropsType<typeof shapePropsConfig>\n * // Result: { width: number; height: number; color?: string }\n * ```\n *\n * @public\n */\nexport type RecordPropsType<Config extends Record<string, T.Validatable<any>>> =\n\tMakeUndefinedOptional<{\n\t\t[K in keyof Config]: T.TypeOf<Config[K]>\n\t}>\n\n/**\n * A migration definition for shape or record properties.\n *\n * Defines how to transform record properties when migrating between schema versions.\n * Each migration has an `up` function to upgrade data and an optional `down` function\n * to downgrade data if needed.\n *\n * @example\n * ```ts\n * const addColorMigration: TLPropsMigration = {\n *   id: 'com.myapp.shape.custom/1.0.0',\n *   up: (props) => {\n *     // Add a default color property\n *     return { ...props, color: 'black' }\n *   },\n *   down: (props) => {\n *     // Remove the color property\n *     const { color, ...rest } = props\n *     return rest\n *   }\n * }\n * ```\n *\n * @public\n */\nexport interface TLPropsMigration {\n\treadonly id: MigrationId\n\treadonly dependsOn?: MigrationId[]\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\treadonly up: (props: any) => any\n\t/**\n\t * If a down migration was deployed more than a couple of months ago it should be safe to retire it.\n\t * We only really need them to smooth over the transition between versions, and some folks do keep\n\t * browser tabs open for months without refreshing, but at a certain point that kind of behavior is\n\t * on them. Plus anyway recently chrome has started to actually kill tabs that are open for too long\n\t * rather than just suspending them, so if other browsers follow suit maybe it's less of a concern.\n\t *\n\t * @public\n\t */\n\treadonly down?: 'none' | 'retired' | ((props: any) => any)\n}\n\n/**\n * A sequence of property migrations for a record type.\n *\n * Contains an ordered array of migrations that should be applied to transform\n * record properties from one version to another. Migrations can include both\n * property-specific migrations and standalone dependency declarations.\n *\n * @example\n * ```ts\n * const myShapeMigrations: TLPropsMigrations = {\n *   sequence: [\n *     {\n *       id: 'com.myapp.shape.custom/1.0.0',\n *       up: (props) => ({ ...props, version: 1 })\n *     },\n *     {\n *       id: 'com.myapp.shape.custom/2.0.0',\n *       up: (props) => ({ ...props, newFeature: true })\n *     }\n *   ]\n * }\n * ```\n *\n * @public\n */\nexport interface TLPropsMigrations {\n\treadonly sequence: Array<StandaloneDependsOn | TLPropsMigration>\n}\n\n/**\n * Processes property migrations for all record types in a schema.\n *\n * Takes a collection of record configurations and converts their migrations\n * into proper migration sequences that can be used by the store system.\n * Handles different migration formats including legacy migrations.\n *\n * @param typeName - The base type name for the records (e.g., 'shape', 'binding')\n * @param records - Record of type names to their schema configuration\n * @returns Array of processed migration sequences\n *\n * @example\n * ```ts\n * const shapeRecords = {\n *   geo: { props: geoProps, migrations: geoMigrations },\n *   arrow: { props: arrowProps, migrations: arrowMigrations }\n * }\n *\n * const sequences = processPropsMigrations('shape', shapeRecords)\n * ```\n *\n * @internal\n */\nexport function processPropsMigrations<R extends UnknownRecord & { type: string; props: object }>(\n\ttypeName: R['typeName'],\n\trecords: Record<string, SchemaPropsInfo>\n) {\n\tconst result: MigrationSequence[] = []\n\n\tfor (const [subType, { migrations }] of Object.entries(records)) {\n\t\tconst sequenceId = `com.tldraw.${typeName}.${subType}`\n\t\tif (!migrations) {\n\t\t\t// provide empty migrations sequence to allow for future migrations\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: true,\n\t\t\t\t\tsequence: [],\n\t\t\t\t})\n\t\t\t)\n\t\t} else if ('sequenceId' in migrations) {\n\t\t\tassert(\n\t\t\t\tsequenceId === migrations.sequenceId,\n\t\t\t\t`sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`\n\t\t\t)\n\t\t\tresult.push(migrations)\n\t\t} else if ('sequence' in migrations) {\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: true,\n\t\t\t\t\tsequence: migrations.sequence.map((m) =>\n\t\t\t\t\t\t'id' in m ? createPropsMigration(typeName, subType, m) : m\n\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t)\n\t\t} else {\n\t\t\t// legacy migrations, will be removed in the future\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: true,\n\t\t\t\t\tsequence: Object.keys(migrations.migrators)\n\t\t\t\t\t\t.map((k) => Number(k))\n\t\t\t\t\t\t.sort((a: number, b: number) => a - b)\n\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t(version): Migration => ({\n\t\t\t\t\t\t\t\tid: `${sequenceId}/${version}`,\n\t\t\t\t\t\t\t\tscope: 'record',\n\t\t\t\t\t\t\t\tfilter: (r) => r.typeName === typeName && (r as R).type === subType,\n\t\t\t\t\t\t\t\tup: (record: any) => {\n\t\t\t\t\t\t\t\t\tconst result = migrations.migrators[version].up(record)\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tdown: (record: any) => {\n\t\t\t\t\t\t\t\t\tconst result = migrations.migrators[version].down(record)\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\treturn result\n}\n\n/**\n * Creates a store migration from a props migration definition.\n *\n * Converts a high-level property migration into a low-level store migration\n * that can be applied to records. The resulting migration will only affect\n * records of the specified type and subtype.\n *\n * @param typeName - The base type name (e.g., 'shape', 'binding')\n * @param subType - The specific subtype (e.g., 'geo', 'arrow')\n * @param m - The property migration definition\n * @returns A store migration that applies the property transformation\n *\n * @example\n * ```ts\n * const propsMigration: TLPropsMigration = {\n *   id: 'com.myapp.shape.custom/1.0.0',\n *   up: (props) => ({ ...props, color: 'blue' })\n * }\n *\n * const storeMigration = createPropsMigration('shape', 'custom', propsMigration)\n * ```\n *\n * @internal\n */\nexport function createPropsMigration<R extends UnknownRecord & { type: string; props: object }>(\n\ttypeName: R['typeName'],\n\tsubType: R['type'],\n\tm: TLPropsMigration\n): Migration {\n\treturn {\n\t\tid: m.id,\n\t\tdependsOn: m.dependsOn,\n\t\tscope: 'record',\n\t\tfilter: (r) => r.typeName === typeName && (r as R).type === subType,\n\t\tup: (record: any) => {\n\t\t\tconst result = m.up(record.props)\n\t\t\tif (result) {\n\t\t\t\trecord.props = result\n\t\t\t}\n\t\t},\n\t\tdown:\n\t\t\ttypeof m.down === 'function'\n\t\t\t\t? (record: any) => {\n\t\t\t\t\t\tconst result = (m.down as (props: any) => any)(record.props)\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\trecord.props = result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAQO;AACP,mBAA8C;AAmJvC,SAAS,uBACf,UACA,SACC;AACD,QAAM,SAA8B,CAAC;AAErC,aAAW,CAAC,SAAS,EAAE,WAAW,CAAC,KAAK,OAAO,QAAQ,OAAO,GAAG;AAChE,UAAM,aAAa,cAAc,QAAQ,IAAI,OAAO;AACpD,QAAI,CAAC,YAAY;AAEhB,aAAO;AAAA,YACN,sCAAwB;AAAA,UACvB;AAAA,UACA,aAAa;AAAA,UACb,UAAU,CAAC;AAAA,QACZ,CAAC;AAAA,MACF;AAAA,IACD,WAAW,gBAAgB,YAAY;AACtC;AAAA,QACC,eAAe,WAAW;AAAA,QAC1B,2BAA2B,OAAO,IAAI,uBAAU,0BAA0B,UAAU,WAAW,WAAW,UAAU;AAAA,MACrH;AACA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,cAAc,YAAY;AACpC,aAAO;AAAA,YACN,sCAAwB;AAAA,UACvB;AAAA,UACA,aAAa;AAAA,UACb,UAAU,WAAW,SAAS;AAAA,YAAI,CAAC,MAClC,QAAQ,IAAI,qBAAqB,UAAU,SAAS,CAAC,IAAI;AAAA,UAC1D;AAAA,QACD,CAAC;AAAA,MACF;AAAA,IACD,OAAO;AAEN,aAAO;AAAA,YACN,sCAAwB;AAAA,UACvB;AAAA,UACA,aAAa;AAAA,UACb,UAAU,OAAO,KAAK,WAAW,SAAS,EACxC,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC,EACpB,KAAK,CAAC,GAAW,MAAc,IAAI,CAAC,EACpC;AAAA,YACA,CAAC,aAAwB;AAAA,cACxB,IAAI,GAAG,UAAU,IAAI,OAAO;AAAA,cAC5B,OAAO;AAAA,cACP,QAAQ,CAAC,MAAM,EAAE,aAAa,YAAa,EAAQ,SAAS;AAAA,cAC5D,IAAI,CAAC,WAAgB;AACpB,sBAAMA,UAAS,WAAW,UAAU,OAAO,EAAE,GAAG,MAAM;AACtD,oBAAIA,SAAQ;AACX,yBAAOA;AAAA,gBACR;AAAA,cACD;AAAA,cACA,MAAM,CAAC,WAAgB;AACtB,sBAAMA,UAAS,WAAW,UAAU,OAAO,EAAE,KAAK,MAAM;AACxD,oBAAIA,SAAQ;AACX,yBAAOA;AAAA,gBACR;AAAA,cACD;AAAA,YACD;AAAA,UACD;AAAA,QACF,CAAC;AAAA,MACF;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;AA0BO,SAAS,qBACf,UACA,SACA,GACY;AACZ,SAAO;AAAA,IACN,IAAI,EAAE;AAAA,IACN,WAAW,EAAE;AAAA,IACb,OAAO;AAAA,IACP,QAAQ,CAAC,MAAM,EAAE,aAAa,YAAa,EAAQ,SAAS;AAAA,IAC5D,IAAI,CAAC,WAAgB;AACpB,YAAM,SAAS,EAAE,GAAG,OAAO,KAAK;AAChC,UAAI,QAAQ;AACX,eAAO,QAAQ;AAAA,MAChB;AAAA,IACD;AAAA,IACA,MACC,OAAO,EAAE,SAAS,aACf,CAAC,WAAgB;AACjB,YAAM,SAAU,EAAE,KAA6B,OAAO,KAAK;AAC3D,UAAI,QAAQ;AACX,eAAO,QAAQ;AAAA,MAChB;AAAA,IACD,IACC;AAAA,EACL;AACD;",
  "names": ["result"]
}
