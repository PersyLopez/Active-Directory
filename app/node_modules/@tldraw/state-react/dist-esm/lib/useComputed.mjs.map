{
  "version": 3,
  "sources": ["../../src/lib/useComputed.ts"],
  "sourcesContent": ["/* eslint-disable prefer-rest-params */\nimport { Computed, ComputedOptions, computed } from '@tldraw/state'\nimport { useMemo } from 'react'\n\n/**\n * Creates a new computed signal that automatically tracks its dependencies and recalculates when they change.\n * This overload is for basic computed values without custom options.\n *\n * @param name - A descriptive name for the computed signal, used for debugging and identification\n * @param compute - A function that computes the value, automatically tracking any signal dependencies\n * @param deps - React dependency array that controls when the computed signal is recreated\n * @returns A computed signal containing the calculated value\n *\n * @example\n * ```ts\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n *\n * function UserProfile() {\n *   const fullName = useComputed(\n *     'fullName',\n *     () => `${firstName.get()} ${lastName.get()}`,\n *     [firstName, lastName]\n *   )\n *\n *   return <div>Welcome, {fullName.get()}!</div>\n * }\n * ```\n *\n * @public\n */\nexport function useComputed<Value>(name: string, compute: () => Value, deps: any[]): Computed<Value>\n\n/**\n * Creates a new computed signal with custom options for advanced behavior like custom equality checking,\n * diff computation, and history tracking. The computed signal will be created only once.\n *\n * @param name - A descriptive name for the computed signal, used for debugging and identification\n * @param compute - A function that computes the value, automatically tracking any signal dependencies\n * @param opts - Configuration options for the computed signal\n *   - isEqual - Custom equality function to determine if the computed value has changed\n *   - computeDiff - Function to compute diffs between old and new values for history tracking\n *   - historyLength - Maximum number of diffs to keep in history buffer for time-travel functionality\n * @param deps - React dependency array that controls when the computed signal is recreated\n * @returns A computed signal containing the calculated value with the specified options\n *\n * @example\n * ```ts\n * function ShoppingCart() {\n *   const items = useAtom('items', [])\n *\n *   // Computed with custom equality to avoid recalculation for equivalent arrays\n *   const sortedItems = useComputed(\n *     'sortedItems',\n *     () => items.get().sort((a, b) => a.name.localeCompare(b.name)),\n *     {\n *       isEqual: (a, b) => a.length === b.length && a.every((item, i) => item.id === b[i].id)\n *     },\n *     [items]\n *   )\n *\n *   return <ItemList items={sortedItems.get()} />\n * }\n * ```\n *\n * @public\n */\nexport function useComputed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: () => Value,\n\topts: ComputedOptions<Value, Diff>,\n\tdeps: any[]\n): Computed<Value>\n/**\n * Implementation function that handles both overloaded signatures of useComputed.\n * Uses the arguments object to dynamically determine which signature was called.\n *\n * This function creates a memoized computed signal that automatically tracks dependencies\n * and only recreates when the dependency array changes, providing optimal performance\n * in React components.\n *\n * @public\n */\nexport function useComputed() {\n\tconst name = arguments[0]\n\tconst compute = arguments[1]\n\tconst opts = arguments.length === 3 ? undefined : arguments[2]\n\tconst deps = arguments.length === 3 ? arguments[2] : arguments[3]\n\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\treturn useMemo(() => computed(`useComputed(${name})`, compute, opts), deps)\n}\n"],
  "mappings": "AACA,SAAoC,gBAAgB;AACpD,SAAS,eAAe;AAiFjB,SAAS,cAAc;AAC7B,QAAM,OAAO,UAAU,CAAC;AACxB,QAAM,UAAU,UAAU,CAAC;AAC3B,QAAM,OAAO,UAAU,WAAW,IAAI,SAAY,UAAU,CAAC;AAC7D,QAAM,OAAO,UAAU,WAAW,IAAI,UAAU,CAAC,IAAI,UAAU,CAAC;AAEhE,SAAO,QAAQ,MAAM,SAAS,eAAe,IAAI,KAAK,SAAS,IAAI,GAAG,IAAI;AAC3E;",
  "names": []
}
